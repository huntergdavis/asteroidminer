<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AstroMiner — Performance Rescue • Pooled Loot Flares • Dynamic Res</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --ret: rgba(173,216,255,.9);
    --retGlow: rgba(120,180,255,.55);
    --retGlow2: rgba(120,180,255,.35);
    --retScale: 1;
  }
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#eef}
  #app{position:fixed;inset:0;overflow:hidden}

  .hud{position:absolute;left:10px;top:10px;background:rgba(0,0,0,.45);padding:10px 12px;border-radius:12px;font-size:12px;backdrop-filter:blur(2px);line-height:1.25;z-index:5}
  .shop{position:absolute;right:10px;top:10px;background:rgba(0,0,0,.55);padding:10px 12px;border-radius:12px;min-width:260px;max-width:420px;font-size:12px;z-index:7;display:none}
  .shop h3{margin:0 0 6px;font-size:13px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0}
  .row button{background:#1f3b8f;border:0;color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}
  .row button[disabled]{opacity:.45;cursor:not-allowed}
  .k{opacity:.8}
  .bar{height:8px;background:#223;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(#66e,#44a);width:0}
  .bar.red>span{background:linear-gradient(#f66,#b22)}
  .bar>span.warn{animation:blink .35s linear infinite alternate}
  @keyframes blink{from{filter:brightness(1)}to{filter:brightness(2.1)}}
  .cash{font-weight:700}
  .help{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:12px;max-width:980px;z-index:5}
  .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:10px;font-size:12px;display:none;z-index:10}
  .err{position:absolute;right:10px;bottom:10px;background:#300;color:#fee;padding:8px 10px;border-radius:10px;max-width:60ch;display:none;white-space:pre-wrap;z-index:10}

  .ret{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(var(--retScale));pointer-events:none;opacity:.9;z-index:4}
  .ret .ring{width:46px;height:46px;border:2px solid var(--ret);border-radius:50%;box-shadow:0 0 18px var(--retGlow) inset,0 0 22px var(--retGlow2)}
  .ret .lines{position:absolute;left:0;top:0;width:46px;height:46px}
  .ret .lines::before,.ret .lines::after{content:"";position:absolute;background:var(--ret)}
  .ret .lines::before{left:50%;top:-10px;transform:translateX(-50%);width:2px;height:12px;box-shadow:0 44px 0 0 var(--ret)}
  .ret .lines::after{top:50%;left:-10px;transform:translateY(-50%);height:2px;width:12px;box-shadow:44px 0 0 0 var(--ret)}

  .flash{position:fixed;inset:0;pointer-events:none;opacity:0;mix-blend-mode:screen;background:
    radial-gradient(ellipse at center, rgba(255,255,255,.14), rgba(0,0,0,0) 60%);z-index:3}

  .fps{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,.55);padding:8px 10px;border-radius:10px;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:none;z-index:6}

  .tgtHud{position:absolute;left:50%;top:50%;transform:translate(-50%,calc(-50% + 42px));font-size:12px;opacity:.9;background:rgba(0,0,0,.35);padding:4px 6px;border-radius:6px;z-index:5;pointer-events:none;display:none}

  .nav{position:absolute;left:50%;top:20px;transform:translate(-50%,0);display:none;align-items:center;gap:6px;background:rgba(0,0,0,.35);padding:4px 6px;border-radius:8px;font-size:12px;z-index:6;pointer-events:none}
  .navArrow{width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid #7fffd4;transform-origin:50% 60%;}
  .navLbl{opacity:.9}

  .loading{position:fixed;inset:0;background:radial-gradient(ellipse at center,#0a0f1a 10%,#000 70%);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:#cfe6ff;z-index:20}
  .spinner{width:44px;height:44px;border-radius:50%;border:4px solid rgba(120,180,255,.25);border-top-color:#7fb2ff;animation:spin 0.9s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .loadbar{width:min(420px,80vw);height:8px;background:#12223a;border-radius:10px;overflow:hidden;box-shadow:0 0 0 1px #1b2a46 inset}
  .loadbar>span{display:block;height:100%;width:0;background:linear-gradient(90deg,#66aaff,#44e);border-radius:10px}
  .loading small{opacity:.8}

  .modalMask{position:fixed;inset:0;background:rgba(0,0,0,.6);backdrop-filter:blur(2px);display:none;align-items:center;justify-content:center;z-index:15}
  .modal{background:rgba(5,10,18,.92);border:1px solid #1b2a46;border-radius:14px;padding:14px 16px;min-width:300px;max-width:min(760px,90vw);color:#cfe6ff}
  .modal h3{margin:0 0 10px 0;font-size:14px}
  .grid{display:grid;grid-template-columns:1fr auto;gap:8px 10px;align-items:center}
  .btn{background:#1f3b8f;border:0;color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer}
  .btn.sec{background:#2a394f}
  .muted{opacity:.75}

  .dockStats{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin:8px 0 10px 0;font-size:12px}
  .statBox{background:#0b1220;border:1px solid #1b2a46;border-radius:8px;padding:6px}

  .hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-70px);background:rgba(0,0,0,.5);padding:8px 10px;border-radius:10px;font-size:12px;z-index:6;pointer-events:none;text-align:center}
  .hint.hide{display:none}
</style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Seed:</b> <span id="uiSeed">0</span> · <b>Quality:</b> <span id="uiQual">High</span></div>
  <div style="margin-top:6px"><b>Speed:</b> <span id="uiSpd">0</span> m/s · <b>Thrust:</b> <span id="uiThrust">0</span>% · <b>Range:</b> <span id="uiRange">0</span> m</div>
  <div style="margin-top:6px"><b>Boost</b><div class="bar"><span id="barBoost"></span></div></div>
  <div style="margin-top:6px"><b>Laser Heat</b><div class="bar"><span id="barLaser"></span></div></div>
  <div style="margin-top:6px"><b>Missile Heat</b><div class="bar red"><span id="barMiss"></span></div></div>
  <div style="margin-top:6px"><b>Cargo</b>: <span id="uiCargo">0</span> / <span id="uiCap">100</span></div>
  <div><b>Credits</b>: <span class="cash" id="uiCredits">0</span></div>
  <div style="margin-top:6px"><b>Station</b>: <span id="uiRef">—</span> m (Dock: <b>C</b>)</div>
</div>

<div class="shop" id="shop">
  <h3>Ship Upgrades</h3>
  <div class="row"><span>Laser Damage Lv <b id="lvLaserD">1</b></span><button id="buyLaserD">Buy (<span id="costLaserD">200</span>)</button></div>
  <div class="row"><span>Laser Cooling Lv <b id="lvLaserC">1</b></span><button id="buyLaserC">Buy (<span id="costLaserC">150</span>)</button></div>
  <div class="row"><span>Laser ROF Lv <b id="lvRof">1</b></span><button id="buyRof">Buy (<span id="costRof">240</span>)</button></div>
  <div class="row"><span>Missile Damage Lv <b id="lvMissD">1</b></span><button id="buyMissD">Buy (<span id="costMissD">300</span>)</button></div>
  <div class="row"><span>Missile Cooling Lv <b id="lvMissC">1</b></span><button id="buyMissC">Buy (<span id="costMissC">220</span>)</button></div>
  <div class="row"><span>Engine Thrust Lv <b id="lvThrust">1</b></span><button id="buyThrust">Buy (<span id="costThrust">250</span>)</button></div>
  <div class="row"><span>Turn Rate Lv <b id="lvTurn">1</b></span><button id="buyTurn">Buy (<span id="costTurn">200</span>)</button></div>
  <div class="row"><span>Dampers Lv <b id="lvBrake">1</b></span><button id="buyBrake">Buy (<span id="costBrake">140</span>)</button></div>
  <div class="row"><span>Cargo Magnet Lv <b id="lvMag">1</b></span><button id="buyMag">Buy (<span id="costMag">180</span>)</button></div>
  <div class="row"><span>Range Extender Lv <b id="lvRange">1</b></span><button id="buyRange">Buy (<span id="costRange">260</span>)</button></div>
  <div class="row"><span>Cargo Hold Lv <b id="lvHold">1</b></span><button id="buyHold">Buy (<span id="costHold">220</span>)</button></div>
  <div class="row"><span>Refinery Yield Lv <b id="lvYield">1</b></span><button id="buyYield">Buy (<span id="costYield">300</span>)</button></div>
  <div class="row"><span>Afterburner Lv <b id="lvBoost">1</b></span><button id="buyBoost">Buy (<span id="costBoost">280</span>)</button></div>
  <div class="row"><span>Scanner Lv <b id="lvScan">1</b></span><button id="buyScan">Buy (<span id="costScan">230</span>)</button></div>
  <div class="row"><span>Targeting Computer Lv <b id="lvTarget">1</b></span><button id="buyTarget">Buy (<span id="costTarget">260</span>)</button></div>
  <hr style="border-color:#234">
  <div class="row"><span class="k">Lightning Beam</span><button id="unlockLightning">Locked (1200)</button></div>
  <div class="row"><span class="k">Mass Driver</span><button id="unlockMass">Locked (900)</button></div>
  <div class="row"><span class="k">Gravity Gun</span><button id="unlockGrav">Locked (1500)</button></div>
  <div style="margin-top:6px;opacity:.75">
    Shop: <b>U</b> · Quality: <b>1</b>/<b>2</b> · New Seed: <b>N</b> · Boost: <b>Shift</b> · FPS: <b>Shift+F</b> · Cycle Nav: <b>H</b> · Mouse Aim: Click in (Options to toggle)
  </div>
</div>

<div class="help">
  <div><b>Controls</b> — Zero‑G 6‑DOF</div>
  <div>Pitch: <b>W/S</b> · Yaw: <b>A/D</b> · Roll: <b>Q/E</b> (or <b>Hold MMB</b> + move mouse left/right)</div>
  <div>Forward/Reverse: <b>↑/↓</b> or <b>Mouse Wheel</b> · Strafe: <b>←/→</b> · Lift: <b>R/F</b> · Boost: <b>Shift</b></div>
  <div>Brake/Damp: <b>Z</b> · Laser: <b>Space</b>/<b>LMB</b> · Missile: <b>X</b>/<b>RMB</b> · Dock: <b>C</b> · Options: <b>O</b>/<b>Esc</b> · <b>Cycle Nav: H</b></div>
  <div>Mouse Aim: <b>Click the playfield</b> to capture. <b>LMB</b>=Laser · <b>RMB</b>=Missile · <b>Wheel</b>=Throttle ± · <b>Hold MMB</b>=Barrel Roll · <b>Esc</b> to release.</div>
</div>

<div class="ret"><div class="ring"></div><div class="lines"></div></div>
<div class="tgtHud" id="tgtHud">—</div>

<div class="nav" id="nav"><div class="navArrow" id="navArrow"></div><div class="navLbl"><span id="navName">STATION</span> <span id="navDist">—</span> m</div></div>

<div class="flash" id="flash"></div>
<div class="fps" id="fps">—</div>
<div class="toast" id="toast"></div>
<div class="err" id="err"></div>

<div class="modalMask" id="optMask">
  <div class="modal">
    <h3>Options</h3>
    <div class="grid">
      <div>Sound FX</div><div><button class="btn sec" id="optSfx">—</button></div>
      <div>Mouse Aim</div><div><button class="btn sec" id="optMouse">—</button></div>
      <div>Quality</div><div><button class="btn sec" id="optQual">—</button></div>
      <div>FOV</div><div><button class="btn sec" id="optFovDown">−</button> <span id="optFovVal" class="muted">75</span> <button class="btn sec" id="optFovUp">+</button></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button class="btn sec" id="optClose">Close</button>
    </div>
  </div>
</div>

<div class="modalMask" id="dockMask">
  <div class="modal">
    <h3>Docked at Orbital Station</h3>
    <div class="dockStats">
      <div class="statBox"><b>Credits</b><br><span id="dsCredits">0</span></div>
      <div class="statBox"><b>Cargo</b><br><span id="dsCargo">0/0</span></div>
      <div class="statBox"><b>Speed</b><br><span id="dsSpeed">0</span> m/s</div>
    </div>
    <div class="muted" style="margin-bottom:8px">Refine cargo with <b>Yield</b> upgrades for bonus payout. You can undock anytime.</div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin:8px 0 6px">
      <button class="btn" id="dockRefine">Refine & Sell Cargo</button>
      <button class="btn sec" id="dockUndock">Undock</button>
    </div>
    <div id="dockShopMount"></div>
  </div>
</div>

<div class="loading" id="loading">
  <div class="spinner"></div>
  <div id="loadText">Generating sector…</div>
  <div class="loadbar"><span id="loadBar"></span></div>
  <small id="loadSub">Preparing…</small>
</div>

<div class="hint" id="mouseHint">Click to enable <b>Mouse Aim</b> · LMB: Laser · RMB: Missile · Wheel: Throttle ± · Hold MMB: Barrel Roll · Esc: Release</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- Utils ---------- */
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const rad=THREE.MathUtils.degToRad;
const lerp=THREE.MathUtils.lerp;
const nextFrame=()=>new Promise(r=>requestAnimationFrame(r));
function rng(seed){ let s=seed>>>0; return ()=>{ s+=0x6D2B79F5; let t=Math.imul(s^(s>>>15),1|s); t^=t+Math.imul(t^(t>>>7),61|t); return ((t^(t>>>14))>>>0)/4294967296; }; }

/* ---------- Scene (no logarithmic depth) ---------- */
const app=document.getElementById('app');
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.3,260000);
camera.position.set(0,0,0);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:false,powerPreference:'high-performance'});
renderer.outputColorSpace = THREE.SRGBColorSpace;
const DPR_MAX=Math.min(devicePixelRatio,2), DPR_MIN=0.6;
let currentDPR=Math.min(devicePixelRatio,2);
renderer.setPixelRatio(currentDPR); renderer.setSize(innerWidth,innerHeight);
renderer.domElement.style.outline='none';
renderer.domElement.tabIndex = 1;
app.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x222233,0.95));
const sun=new THREE.DirectionalLight(0xffffff,0.8); sun.position.set(1,0.2,0.3).multiplyScalar(30000); scene.add(sun);

/* ---------- UI refs ---------- */
const byId = id=>document.getElementById(id);
const ui={
  seed:byId('uiSeed'), qual:byId('uiQual'),
  spd:byId('uiSpd'), range:byId('uiRange'), thrustPct:byId('uiThrust'),
  barBoost:byId('barBoost'), barLaser:byId('barLaser'), barMiss:byId('barMiss'),
  credits:byId('uiCredits'), cargo:byId('uiCargo'), cap:byId('uiCap'),
  toast:byId('toast'), err:byId('err'),
  shop:byId('shop'), dockShopMount:byId('dockShopMount'),
  lvLaserD:byId('lvLaserD'), lvLaserC:byId('lvLaserC'), lvMissD:byId('lvMissD'),
  lvThrust:byId('lvThrust'), lvTurn:byId('lvTurn'), lvMag:byId('lvMag'),
  costLaserD:byId('costLaserD'), costLaserC:byId('costLaserC'), costMissD:byId('costMissD'),
  costThrust:byId('costThrust'), costTurn:byId('costTurn'), costMag:byId('costMag'),
  lvRange:byId('lvRange'), lvHold:byId('lvHold'), lvYield:byId('lvYield'),
  costRange:byId('costRange'), costHold:byId('costHold'), costYield:byId('costYield'),
  lvRof:byId('lvRof'), costRof:byId('costRof'),
  lvBoost:byId('lvBoost'), costBoost:byId('costBoost'),
  lvScan:byId('lvScan'), costScan:byId('costScan'),
  lvMissC:byId('lvMissC'), costMissC:byId('costMissC'),
  lvBrake:byId('lvBrake'), costBrake:byId('costBrake'),
  lvTarget:byId('lvTarget'), costTarget:byId('costTarget'),

  ref:byId('uiRef'),
  flash:byId('flash'),
  fps:byId('fps'),
  tgtHud:byId('tgtHud'),
  nav:byId('nav'), navArrow:byId('navArrow'), navDist:byId('navDist'), navName:byId('navName'),
  loading:byId('loading'), loadText:byId('loadText'), loadSub:byId('loadSub'), loadBar:byId('loadBar'),
  optMask:byId('optMask'), dockMask:byId('dockMask'),
  dsCredits:byId('dsCredits'), dsCargo:byId('dsCargo'), dsSpeed:byId('dsSpeed'),
  optSfx:byId('optSfx'), optMouse:byId('optMouse'), optQual:byId('optQual'),
  optFovDown:byId('optFovDown'), optFovUp:byId('optFovUp'), optFovVal:byId('optFovVal'),
  mouseHint:byId('mouseHint'),
  buttons:{
    buyLaserD:byId('buyLaserD'), buyLaserC:byId('buyLaserC'), buyMissD:byId('buyMissD'),
    buyThrust:byId('buyThrust'), buyTurn:byId('buyTurn'), buyMag:byId('buyMag'),
    buyRange:byId('buyRange'), buyHold:byId('buyHold'), buyYield:byId('buyYield'),
    buyRof:byId('buyRof'), buyBoost:byId('buyBoost'), buyScan:byId('buyScan'),
    unlockLightning:byId('unlockLightning'), unlockMass:byId('unlockMass'), unlockGrav:byId('unlockGrav'),
    buyMissC:byId('buyMissC'), buyBrake:byId('buyBrake'), buyTarget:byId('buyTarget')
  }
};
function toast(msg,ms=1200){ ui.toast.textContent=msg; ui.toast.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>ui.toast.style.display='none',ms); }
function showError(e){ ui.err.style.display='block'; ui.err.textContent=(typeof e==='string')?e:(e?.message||String(e)); console.error(e); }
addEventListener('error', e=>showError(e.error||e.message));
addEventListener('unhandledrejection', e=>showError(e.reason||e));

/* ---------- Loading overlay ---------- */
const Loader={
  show(msg='Loading…'){ ui.loading.style.display='flex'; ui.loadText.textContent=msg; ui.loadSub.textContent='Preparing…'; ui.loadBar.style.width='0%'; },
  sub(msg){ ui.loadSub.textContent=msg; },
  pct(p){ ui.loadBar.style.width=(Math.floor(p*100))+'%'; },
  hide(){ ui.loading.style.display='none'; }
};

/* ---------- Input & Menus ---------- */
const keys={};
let fpsOn=false, paused=false, pauseReason=null;
function setPaused(p, reason=null){ paused=p; pauseReason=reason; if(p){ ui.fps.style.display='none'; } }
function toggleFPS(){ fpsOn=!fpsOn; if(!paused) ui.fps.style.display=fpsOn?'block':'none'; }

addEventListener('keydown',e=>{
  if(e.code==='KeyF' && e.shiftKey){ toggleFPS(); e.preventDefault(); return; }
  keys[e.code]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  if(e.code==='Digit1') setQuality('high');
  if(e.code==='Digit2') setQuality('ultra');
  if(e.code==='KeyN')  newSeed();
  if(e.code==='KeyU'){ ui.shop.style.display = (ui.shop.style.display==='none'?'block':'none'); }
  if(e.code==='KeyO' || e.code==='Escape'){ openOptions(); }
  if(e.code==='KeyH'){ NAV.nextTarget(); }
  if(AUD._ctx && AUD._ctx.state==='suspended') AUD._ctx.resume();
  if(!AUD._ctx) AUD.init();
});
addEventListener('keyup',e=>{ keys[e.code]=false; });

/* ---------- Audio with toggle ---------- */
const Settings = { sfx:true, mouseAim:true, fov:75, quality:'high' };
function loadSettings(){ try{ const j=localStorage.getItem('astrominer_settings'); if(j){ Object.assign(Settings, JSON.parse(j)); } }catch{} }
function saveSettings(){ localStorage.setItem('astrominer_settings', JSON.stringify(Settings)); }

const AUD={
  _ctx:null,
  init(){ try{ const C=window.AudioContext||window.webkitAudioContext; this._ctx=new C(); }catch(e){} },
  ok(){ return Settings.sfx && this._ctx; },
  beep(freq=880,dur=0.05,type='sine',gain=0.03){
    if(!this.ok()) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type=type; o.frequency.setValueAtTime(freq,t);
    g.gain.setValueAtTime(gain,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+dur);
  },
  zap(){ this.beep(880,0.05,'sawtooth',0.05); this.beep(1760,0.05,'triangle',0.03); },
  pickup(){ if(!this.ok()) return; this.beep(1200,0.06,'sine',0.045); setTimeout(()=>this.beep(1600,0.05,'sine',0.035),40); },
  boom(){
    if(!this.ok()) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type='square'; o.frequency.setValueAtTime(80,t); o.frequency.exponentialRampToValueAtTime(30,t+0.3);
    g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.35);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+0.35);
  }
};

/* ---------- Options modal ---------- */
function updateOptionsMirror(){
  ui.optSfx.textContent = Settings.sfx?'On':'Off';
  ui.optMouse.textContent = Settings.mouseAim?'On':'Off';
  ui.optQual.textContent= (quality==='ultra')?'Ultra':'High';
  ui.optFovVal.textContent = String(baseFov);
}
function unlockPointer(){ try{ if(document.pointerLockElement) document.exitPointerLock(); }catch{} }
function openOptions(){ unlockPointer(); setPaused(true,'options'); ui.optMask.style.display='flex'; updateOptionsMirror(); }
function closeOptions(){ ui.optMask.style.display='none'; if(pauseReason==='options'){ setPaused(false,null); if(fpsOn) ui.fps.style.display='block'; } }
ui.optSfx.addEventListener('click',()=>{ Settings.sfx=!Settings.sfx; saveSettings(); updateOptionsMirror(); toast('SFX '+(Settings.sfx?'On':'Off')); });
ui.optMouse.addEventListener('click',()=>{ Settings.mouseAim=!Settings.mouseAim; if(!Settings.mouseAim){ unlockPointer(); MOUSE.fireL=false; MOUSE.fireR=false; } saveSettings(); updateOptionsMirror(); updateMouseHint(); });
ui.optQual.addEventListener('click',()=>{ setQuality(quality==='ultra'?'high':'ultra'); updateOptionsMirror(); });
ui.optFovDown.addEventListener('click',()=>{ baseFov=clamp(baseFov-2,60,95); Settings.fov=baseFov; camera.fov=baseFov; camera.updateProjectionMatrix(); saveSettings(); updateOptionsMirror(); });
ui.optFovUp.addEventListener('click',()=>{ baseFov=clamp(baseFov+2,60,95); Settings.fov=baseFov; camera.fov=baseFov; camera.updateProjectionMatrix(); saveSettings(); updateOptionsMirror(); });
byId('optClose').addEventListener('click',()=>closeOptions());

/* ---------- Ship ---------- */
const ship={
  pos:new THREE.Vector3(), vel:new THREE.Vector3(), quat:new THREE.Quaternion(),
  thrust:48, strafe:36, lift:36,
  yawRate:rad(100), pitchRate:rad(100), rollRate:rad(180),
  dampingLin:0.08, maxSpeed:300, range:3800,
  scannerRange:4200,
  cargo:0, cargoCap:100, credits:0,
  laser:{ canFire:true, heat:0, over:false, cooldown:30, shotHeat:18, dmg:50, rof:10, _cd:0 },
  missile:{ canFire:true, heat:0, over:false, cooldown:18, shotHeat:34, dmg:240, reload:0.7, _cd:0 },
  boost:{ cap:2.0, regen:0.55, val:2.0, mult:2.1 },
  brakeCoeff:0.90,
  seekStrength:0.02
};
let baseFov=75, fovKick=0, flashAmt=0, shakeT=0, shakeAmp=0;

const shipGroup=new THREE.Group(); scene.add(shipGroup); shipGroup.visible=false;
const HP_LOCAL = { laserL:new THREE.Vector3(-0.9,0.55,-1.6), laserR:new THREE.Vector3(0.9,0.55,-1.6), missile:new THREE.Vector3(0,-0.05,-1.9) };
const eyeLocal = new THREE.Vector3(0,0,0);
function hardpointWorld(local){ return local.clone().applyQuaternion(ship.quat).add(ship.pos); }

/* ---------- Mouse aim + Wheel throttle + MMB roll ---------- */
const MOUSE={ yaw:0,pitch:0,roll:0, fireL:false,fireR:false,mmb:false,locked:false, sens:0.0022, sensRoll:0.0032, throttle:0 };
function updateMouseHint(){ ui.mouseHint.classList.toggle('hide', !Settings.mouseAim || MOUSE.locked || paused); }
renderer.domElement.addEventListener('contextmenu',e=>{ e.preventDefault(); });
renderer.domElement.addEventListener('click',()=>{ if(!Settings.mouseAim) return; try{ renderer.domElement.requestPointerLock({unadjustedMovement:true}); }catch{ renderer.domElement.requestPointerLock?.(); }});
document.addEventListener('pointerlockchange',()=>{
  MOUSE.locked = (document.pointerLockElement===renderer.domElement);
  renderer.domElement.style.cursor = MOUSE.locked?'none':'auto';
  if(MOUSE.locked){ toast('Mouse Aim Engaged'); } else { MOUSE.fireL=false; MOUSE.fireR=false; MOUSE.mmb=false; }
  updateMouseHint();
});
renderer.domElement.addEventListener('mousemove',(e)=>{
  if(!Settings.mouseAim || !MOUSE.locked) return;
  const dx = -e.movementX, dy = -e.movementY;
  if(MOUSE.mmb){ MOUSE.roll += dx*MOUSE.sensRoll; MOUSE.pitch += dy*MOUSE.sens; }
  else { MOUSE.yaw += dx*MOUSE.sens; MOUSE.pitch += dy*MOUSE.sens; }
});
renderer.domElement.addEventListener('mousedown',e=>{ if(!Settings.mouseAim) return; if(e.button===0) MOUSE.fireL=true; if(e.button===2) MOUSE.fireR=true; if(e.button===1){ e.preventDefault(); MOUSE.mmb=true; }});
document.addEventListener('mouseup',e=>{ if(e.button===0) MOUSE.fireL=false; if(e.button===2) MOUSE.fireR=false; if(e.button===1) MOUSE.mmb=false; });
window.addEventListener('blur',()=>{ MOUSE.fireL=false; MOUSE.fireR=false; MOUSE.mmb=false; });
renderer.domElement.addEventListener('wheel', e=>{
  if(e.target!==renderer.domElement) return; e.preventDefault(); if(paused) return;
  const raw=(e.deltaMode===1?e.deltaY*16:e.deltaMode===2?e.deltaY*800:e.deltaY);
  const step = clamp(-raw/800, -0.25, 0.25); MOUSE.throttle = clamp(MOUSE.throttle + step, -1, 1);
  ui.thrustPct.textContent = Math.round(MOUSE.throttle*100);
},{passive:false});

/* ---------- Upgrades / Shop / Save ---------- */
const upgrades={ laserD:1, laserC:1, rof:1, missD:1, missC:1, thrust:1, turn:1, brake:1, magnet:1, range:1, hold:1, yield:1, boost:1, scan:1, target:1, lightning:false, mass:false, grav:false };
const baseCosts={ laserD:200, laserC:150, rof:240, missD:300, missC:220, thrust:250, turn:200, brake:140, magnet:180, range:260, hold:220, yield:300, boost:280, scan:230, target:260 };
const MAX={ laserD:8, laserC:8, rof:7, missD:8, missC:7, thrust:8, turn:8, brake:6, magnet:8, range:8, hold:8, yield:6, boost:6, scan:6, target:6 };
function levelCost(base,lv){ return Math.round(base * Math.pow(1.6, lv-1)); }
function applyUpgrades(){
  ship.laser.dmg=50+(upgrades.laserD-1)*18;
  ship.laser.cooldown=30+(upgrades.laserC-1)*6;
  ship.laser.shotHeat=Math.max(8,18-(upgrades.laserC-1)*2);
  ship.laser.rof = 10 + (upgrades.rof-1)*2;

  ship.missile.dmg=240+(upgrades.missD-1)*80;
  ship.missile.cooldown=18+(upgrades.missC-1)*7;
  ship.missile.shotHeat=Math.max(16,34-(upgrades.missC-1)*2);

  ship.thrust = 48 + (upgrades.thrust-1)*7;
  ship.strafe = 36 + (upgrades.thrust-1)*6;
  ship.lift   = 36 + (upgrades.thrust-1)*6;
  ship.maxSpeed = 300 + (upgrades.thrust-1)*24;

  ship.yawRate  = rad(100+(upgrades.turn-1)*10);
  ship.pitchRate= rad(100+(upgrades.turn-1)*10);
  ship.rollRate = rad(180+(upgrades.turn-1)*18);

  ship.brakeCoeff = clamp(0.90 + (upgrades.brake-1)*0.02, 0.90, 0.98);

  ship.cargoCap = 100 + (upgrades.hold-1)*80;
  ship.range = 3800 + (upgrades.range-1)*420;
  ship.scannerRange = 4200 + (upgrades.scan-1)*1400;

  ship.boost.cap = 2.0 + (upgrades.boost-1)*0.9;
  ship.boost.regen = 0.55 + (upgrades.boost-1)*0.25;
  ship.boost.mult = 2.1 + (upgrades.boost-1)*0.12;
  ship.boost.val = Math.min(ship.boost.val, ship.boost.cap);

  ship.seekStrength = clamp(0.02 + (upgrades.target-1)*0.006, 0.02, 0.05);
}
function refreshShop(){
  const C=ui.buttons, cVals={}, set=(k)=>cVals[k]=levelCost(baseCosts[k], upgrades[k]+1);
  ['laserD','laserC','rof','missD','missC','thrust','turn','brake','magnet','range','hold','yield','boost','scan','target'].forEach(set);
  const setLv=(id,val)=>{ byId(id).textContent=val; };
  setLv('lvLaserD',upgrades.laserD); setLv('lvLaserC',upgrades.laserC); setLv('lvRof',upgrades.rof);
  setLv('lvMissD',upgrades.missD); setLv('lvMissC',upgrades.missC);
  setLv('lvThrust',upgrades.thrust); setLv('lvTurn',upgrades.turn); setLv('lvBrake',upgrades.brake);
  setLv('lvMag',upgrades.magnet); setLv('lvRange',upgrades.range); setLv('lvHold',upgrades.hold);
  setLv('lvYield',upgrades.yield); setLv('lvBoost',upgrades.boost); setLv('lvScan',upgrades.scan); setLv('lvTarget',upgrades.target);

  ui.costLaserD.textContent=cVals.laserD; ui.costLaserC.textContent=cVals.laserC; ui.costRof.textContent=cVals.rof;
  ui.costMissD.textContent=cVals.missD; ui.costMissC.textContent=cVals.missC;
  ui.costThrust.textContent=cVals.thrust; ui.costTurn.textContent=cVals.turn; ui.costBrake.textContent=cVals.brake;
  ui.costMag.textContent=cVals.magnet; ui.costRange.textContent=cVals.range; ui.costHold.textContent=cVals.hold;
  ui.costYield.textContent=cVals.yield; ui.costBoost.textContent=cVals.boost; ui.costScan.textContent=cVals.scan; ui.costTarget.textContent=cVals.target;

  const can=(k)=>ship.credits>=cVals[k] && upgrades[k]<MAX[k];
  const capText=(k)=> (upgrades[k]>=MAX[k])?'MAX':'Buy ('+cVals[k]+')';
  function setBtn(btn,key){ btn.disabled=!can(key); btn.textContent=capText(key); }

  setBtn(C.buyLaserD,'laserD'); setBtn(C.buyLaserC,'laserC'); setBtn(C.buyRof,'rof');
  setBtn(C.buyMissD,'missD'); setBtn(C.buyMissC,'missC');
  setBtn(C.buyThrust,'thrust'); setBtn(C.buyTurn,'turn'); setBtn(C.buyBrake,'brake');
  setBtn(C.buyMag,'magnet'); setBtn(C.buyRange,'range'); setBtn(C.buyHold,'hold');
  setBtn(C.buyYield,'yield'); setBtn(C.buyBoost,'boost'); setBtn(C.buyScan,'scan'); setBtn(C.buyTarget,'target');

  const setUnlock=(key,btn,price)=>{ if(upgrades[key]){ btn.textContent='Unlocked'; btn.disabled=true; } else { btn.textContent=`Unlock (${price})`; btn.disabled=(ship.credits<price); } };
  setUnlock('lightning', ui.buttons.unlockLightning, 1200);
  setUnlock('mass',      ui.buttons.unlockMass,       900);
  setUnlock('grav',      ui.buttons.unlockGrav,      1500);
}
function bindShop(){
  const B=ui.buttons, tryBuy=(k,label)=>{ if(upgrades[k]>=MAX[k]) return toast(label+' is maxed');
    const cost=levelCost(baseCosts[k], upgrades[k]+1); if(ship.credits<cost) return toast('Not enough credits');
    ship.credits-=cost; upgrades[k]++; applyUpgrades(); toast(label+' +1'); save(); updateUI(); };
  B.buyLaserD.addEventListener('click',()=>tryBuy('laserD','Laser Damage'));
  B.buyLaserC.addEventListener('click',()=>tryBuy('laserC','Laser Cooling'));
  B.buyRof.addEventListener('click',()=>tryBuy('rof','Laser ROF'));
  B.buyMissD.addEventListener('click',()=>tryBuy('missD','Missile Damage'));
  B.buyMissC.addEventListener('click',()=>tryBuy('missC','Missile Cooling'));
  B.buyThrust.addEventListener('click',()=>tryBuy('thrust','Engine Thrust'));
  B.buyTurn.addEventListener('click',()=>tryBuy('turn','Turn Rate'));
  B.buyBrake.addEventListener('click',()=>tryBuy('brake','Dampers'));
  B.buyMag.addEventListener('click',()=>tryBuy('magnet','Cargo Magnet'));
  B.buyRange.addEventListener('click',()=>tryBuy('range','Range Extender'));
  B.buyHold.addEventListener('click',()=>tryBuy('hold','Cargo Hold'));
  B.buyYield.addEventListener('click',()=>tryBuy('yield','Refinery Yield'));
  B.buyBoost.addEventListener('click',()=>tryBuy('boost','Afterburner'));
  B.buyScan.addEventListener('click',()=>tryBuy('scan','Scanner'));
  B.buyTarget.addEventListener('click',()=>tryBuy('target','Targeting Computer'));
}
const LSKEY='astrominer_save_v1';
function save(){ localStorage.setItem(LSKEY, JSON.stringify({seed,quality,credits:ship.credits,cargo:ship.cargo,upgrades})); }
function load(){ try{ const j=localStorage.getItem(LSKEY); if(!j) return; const d=JSON.parse(j);
  if(d.seed) seed=d.seed; if(d.quality) quality=d.quality; if(d.credits!=null) ship.credits=d.credits; if(d.cargo!=null) ship.cargo=d.cargo; if(d.upgrades) Object.assign(upgrades,d.upgrades);
  applyUpgrades();
}catch(e){ console.warn('save load failed',e); } }

/* ---------- Sky & stars ---------- */
function finalizeGlowTexture(t){ t.anisotropy=2; t.generateMipmaps=false; t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; t.premultiplyAlpha=true; t.colorSpace=THREE.SRGBColorSpace; t.needsUpdate=true; return t; }
function makeGlowTexture(size=96, inner=0.0, outer=1.0, col='rgba(255,240,140,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer); g.addColorStop(0,col); g.addColorStop(1,'rgba(0,0,0,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}
async function makeStarfieldAsync(seed, count, spread=70000, progress){
  const group=new THREE.Group(); const R=rng(seed);
  async function layer(n, spr, size, label){
    const geo=new THREE.BufferGeometry(); const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const r=spr*Math.pow(R(),0.22), th=R()*Math.PI*2, u=R()*2-1, ph=Math.acos(u), s=Math.sin(ph);
      pos[i*3]=r*s*Math.cos(th); pos[i*3+1]=r*Math.cos(ph); pos[i*3+2]=r*s*Math.sin(th);
      if((i&1023)===0){ progress && progress(`${label} ${Math.floor(i/n*100)}%`); await nextFrame(); }
    }
    const mat=new THREE.PointsMaterial({size, color:0xffffff, sizeAttenuation:true, depthWrite:false});
    const pts=new THREE.Points(geo.setAttribute('position',new THREE.BufferAttribute(pos,3)),mat);
    pts.frustumCulled=false; group.add(pts);
  }
  await layer(Math.floor(count*0.6), spread*0.9, 2.0, 'Stars A');
  await layer(Math.floor(count*0.7), spread*1.8, 1.3, 'Stars B');
  await layer(Math.floor(count*0.7), spread*2.6, 1.0, 'Stars C');
  group.frustumCulled=false; return group;
}
let skydome=null, stars=null;
function makeSkydome(seed){
  const R=rng(seed);
  const c0=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c1=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c2=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const mat=new THREE.ShaderMaterial({
    side:THREE.BackSide, depthTest:false, depthWrite:false,
    uniforms:{uC0:{value:c0},uC1:{value:c1},uC2:{value:c2},uCol0:{value:new THREE.Color(0.40,0.30,0.70)},uCol1:{value:new THREE.Color(0.70,0.40,0.20)},uCol2:{value:new THREE.Color(0.20,0.50,0.80)},uBase:{value:new THREE.Color(0.004,0.006,0.010)}},
    vertexShader:`varying vec3 vDir;void main(){vec4 wp=modelMatrix*vec4(position,1.0);vDir=normalize(wp.xyz-cameraPosition);gl_Position=projectionMatrix*viewMatrix*wp;}`,
    fragmentShader:`precision mediump float;varying vec3 vDir;uniform vec3 uC0,uC1,uC2,uCol0,uCol1,uCol2,uBase;
      float lobe(vec3 d,vec3 c,float s){float m=max(0.,dot(normalize(d),normalize(c)));return pow(m,s);}
      void main(){vec3 d=normalize(vDir);float a=lobe(d,uC0,2.0),b=lobe(d,uC1,2.0),c=lobe(d,uC2,2.0);vec3 col=uBase+0.5*(a*uCol0+b*uCol1+c*uCol2);gl_FragColor=vec4(col,1.0);} `
  });
  const g=new THREE.SphereGeometry(220000,32,16);
  const dome=new THREE.Mesh(g,mat); dome.renderOrder=-100; dome.frustumCulled=false; return dome;
}

/* ---------- Field / Drops ---------- */
let quality='high', seed=(Math.random()*1e9)|0;
const AST={ inst:[], data:[], count:0 };
const DROPS={ inst:null, data:[], count:0, cap:0, geo:null, mat:null };
const MISSILES=[], LASER_BEAMS=[];
const TRAWLERS=[];
let FIELDS=[];

const FIELD_FX={ group:new THREE.Group(), dust:[] }; scene.add(FIELD_FX.group);
function clearFieldFX(){ for(const s of FIELD_FX.dust){ FIELD_FX.group.remove(s); s.material.map.dispose(); s.material.dispose(); } FIELD_FX.dust.length=0; }
function buildFieldFX(startCenter,clearR){
  clearFieldFX();
  const dustTex = makeGlowTexture(512, 0.0, 1.0, 'rgba(110,160,220,0.35)');
  for(const f of FIELDS){
    for(let i=0;i<2;i++){
      const s=new THREE.Sprite(new THREE.SpriteMaterial({map:dustTex,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:0.18}));
      let pos; let tries=0;
      do{
        pos=f.center.clone().add(new THREE.Vector3((Math.random()-0.5)*400,(Math.random()-0.5)*150,(Math.random()-0.5)*400));
        tries++;
      }while(f.center.equals(startCenter) && pos.distanceTo(startCenter)<clearR*1.3 && tries<10);
      s.position.copy(pos);
      s.scale.set(1400+Math.random()*600, 1400+Math.random()*600, 1);
      FIELD_FX.group.add(s); FIELD_FX.dust.push(s);
    }
  }
}

/* ---------- Procedural shapes ---------- */
function hash3(x,y,z){ return (Math.sin(x*127.1 + y*311.7 + z*74.7)*43758.5453)%1; }
function fbm3(x,y,z,oct=3){ let a=0, amp=1, freq=1; for(let i=0;i<oct;i++){ a+= (hash3(x*freq,y*freq,z*freq)*2-1)*amp; freq*=2.07; amp*=0.55; } return a; }
function geoRock(seed,scale=1){ const g=new THREE.IcosahedronGeometry(scale,1),pos=g.attributes.position;
  for(let i=0;i<pos.count;i++){ const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)), n=v.clone().normalize();
    const d=fbm3(v.x+seed*0.001,v.y-seed*0.002,v.z+seed*0.003,4); v.addScaledVector(n,(d*0.35)+(Math.random()-0.5)*0.08); pos.setXYZ(i,v.x,v.y,v.z); }
  g.computeVertexNormals(); return g;
}
function geoCrystal(seed,scale=1){ const g=new THREE.IcosahedronGeometry(scale,1),pos=g.attributes.position,R=rng(seed);
  for(let i=0;i<pos.count;i++){ const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)); const n=v.clone().normalize(); let k=Math.pow(Math.abs(n.x)+Math.abs(n.y)+Math.abs(n.z),1.25); k+=(R()-0.5)*0.12; v.addScaledVector(n,k*0.55); pos.setXYZ(i,v.x,v.y,v.z); }
  g.computeVertexNormals(); return g;
}
function geoMetal(seed,scale=1){ const g=new THREE.IcosahedronGeometry(scale,1),pos=g.attributes.position;
  for(let i=0;i<pos.count;i++){ const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)), n=v.clone().normalize();
    const d=fbm3(v.x*0.6+seed*0.001,v.y*0.6-seed*0.002,v.z*0.6+seed*0.003,3); v.addScaledVector(n,(d*0.18)+(Math.random()-0.5)*0.04); pos.setXYZ(i,v.x,v.y,v.z); }
  g.computeVertexNormals(); return g;
}

/* ---------- Materials ---------- */
function makeMatRock(){ const m=new THREE.MeshStandardMaterial({color:0x8a929c, roughness:0.97, metalness:0.03, vertexColors:true, flatShading:true});
  m.onBeforeCompile=(s)=>{ s.fragmentShader = s.fragmentShader.replace('#include <emissivemap_fragment>',`#include <emissivemap_fragment>
    float fres = pow(1.0 - saturate(dot(normalize(normal), normalize(vViewPosition))), 3.0);
    #ifdef USE_COLOR
      totalEmissiveRadiance += vec3(0.10) * fres * (0.6 + 0.4*length(vColor));
    #else
      totalEmissiveRadiance += vec3(0.10) * fres;
    #endif` ); }; return m; }
function makeMatCrystal(){ const m=new THREE.MeshStandardMaterial({color:0x8bd7ff, roughness:0.18, metalness:0.0, emissive:new THREE.Color(0x206080), emissiveIntensity:0.25, vertexColors:true, flatShading:true});
  m.onBeforeCompile=(s)=>{ s.fragmentShader = s.fragmentShader.replace('#include <emissivemap_fragment>',`#include <emissivemap_fragment>
    float fres = pow(1.0 - saturate(dot(normalize(normal), normalize(vViewPosition))), 2.5);
    totalEmissiveRadiance += vec3(0.20,0.55,0.65) * fres;` ); }; return m; }
function makeMatMetal(){ return new THREE.MeshStandardMaterial({color:0x6f7885, roughness:0.60, metalness:0.95, vertexColors:true, flatShading:true}); }

/* ---------- Build Multi‑Field Asteroids (async) ---------- */
async function buildAsteroidsAsync(seed, progress){
  AST.inst.forEach(im=>{ scene.remove(im); im.geometry.dispose(); im.material.dispose(); });
  AST.inst=[]; AST.data=[]; AST.count=0; FIELDS=[];

  const R=rng(seed^0xBEEF);
  const fields = (quality==='ultra')?6:4;
  const basePerField = (quality==='ultra')?780:520; /* slightly reduced for perf */
  const baseCount = basePerField * fields;

  const frac = { rock:0.90, crystal:0.06, metal:0.03, giants:0.01 };
  const counts={ rock:Math.floor(baseCount*frac.rock), crystal:Math.floor(baseCount*frac.crystal), metal:Math.floor(baseCount*frac.metal), giants:Math.floor(baseCount*frac.giants) };
  const extraCluster = Math.floor(baseCount*0.08);

  const ringR = (quality==='ultra')?8000:6500;
  const START_CENTER = new THREE.Vector3(0,0,0);
  const START_CLEAR_R = 1500;

  FIELDS.push({center:START_CENTER.clone()});
  for(let i=1;i<fields;i++){
    const a = (i/(fields-1))*Math.PI*2 + R()*0.25;
    const c=new THREE.Vector3(Math.cos(a)*ringR,(R()*2-1)*420,Math.sin(a)*ringR);
    c.add(new THREE.Vector3((R()*2-1)*500,(R()*2-1)*280,(R()*2-1)*500));
    FIELDS.push({center:c});
  }

  const geosRock=[geoRock(seed^0x1111,1.0), geoRock(seed^0x2222,1.25), geoRock(seed^0x3333,0.85)];
  const geosCrystal=[geoCrystal(seed^0x4444,1.0), geoCrystal(seed^0x5555,0.9)];
  const geosMetal=[geoMetal(seed^0x6666,1.1), geoMetal(seed^0x7777,1.2)];
  const matRock=makeMatRock(), matCrystal=makeMatCrystal(), matMetal=makeMatMetal();

  function allocInst(geo,mat,n){ const inst=new THREE.InstancedMesh(geo,mat,n);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    inst.instanceColor=new THREE.InstancedBufferAttribute(new Float32Array(n*3),3);
    inst.frustumCulled=false; scene.add(inst);
    const gi=AST.inst.push(inst)-1; return {inst,gi,count:n,idx:0}; }
  const pools=[];
  function addPools(geos,mat,nTotal){ const split = geos.map((_g,i)=>Math.floor(nTotal/geos.length)+(i===0?nTotal%geos.length:0)); for(let i=0;i<geos.length;i++) pools.push(allocInst(geos[i],mat,split[i])); }
  addPools(geosRock,   matRock,   counts.rock + extraCluster);
  addPools(geosCrystal,matCrystal,counts.crystal);
  addPools(geosMetal,  matMetal,  counts.metal);
  const giantsPool = allocInst(geosRock[0], matRock, counts.giants); pools.push(giantsPool);

  const makeColRock   =()=>new THREE.Color().setHSL(0.60+R()*0.06, 0.12+R()*0.10, 0.58+R()*0.10);
  const makeColCrystal=()=>new THREE.Color().setHSL(0.55+R()*0.20, 0.45+R()*0.25, 0.65+R()*0.20);
  const makeColMetal  =()=>{ const steel=new THREE.Color().setHSL(0.60+R()*0.04,0.12+R()*0.10,0.42+R()*0.08); const copper=new THREE.Color().setHSL(0.06+R()*0.05,0.35+R()*0.15,0.50+R()*0.10); return (R()<0.75)?steel:copper; };

  const beltR=2200,beltW=1000,beltH=700;
  function posInField(fIdx, clustered=false){
    const center=FIELDS[fIdx].center;
    const minR = (fIdx===0) ? (START_CLEAR_R + 400) : 0;

    if(clustered){
      const dir=new THREE.Vector3(R()*2-1,R()*0.6,R()*2-1).normalize();
      const rr = (fIdx===0) ? (minR + 120 + Math.pow(R(),0.7)*320) : (160 + Math.pow(R(),0.7)*420);
      const yj = (R()*2-1)*Math.min(280,beltH);
      return center.clone().add(new THREE.Vector3(dir.x*rr, yj, dir.z*rr));
    } else {
      const a=R()*Math.PI*2, rRaw=beltR+(R()*2-1)*beltW, r=(fIdx===0)?Math.max(rRaw, minR):rRaw;
      const x=Math.cos(a)*r, z=Math.sin(a)*r, y=(R()*2-1)*beltH;
      return center.clone().add(new THREE.Vector3(x,y,z));
    }
  }
  function choosePoolByMat(mat){ for(const p of pools){ if(p.inst.material===mat && p.idx<p.count) return p; } return null; }
  function spawnTo(pool, P, size, hp, color, type){
    if(!pool) return; if(pool.idx>=pool.count) return;
    const q=new THREE.Quaternion().setFromEuler(new THREE.Euler(R()*Math.PI,R()*Math.PI,R()*Math.PI));
    const m=new THREE.Matrix4().compose(P, q, new THREE.Vector3(size,size,size));
    pool.inst.setMatrixAt(pool.idx,m); pool.inst.setColorAt(pool.idx,color);
    AST.data.push({x:P.x,y:P.y,z:P.z,size,hp,alive:true,gi:pool.gi,idx:pool.idx,type});
    pool.idx++; AST.count++;
  }
  function finalizePools(){ for(const p of pools){ p.inst.count=p.idx; p.inst.instanceMatrix.needsUpdate=true; p.inst.instanceColor.needsUpdate=true; } }

  const share=(n)=>Math.floor(n/fields), rem=(n)=>n-share(n)*fields;
  let rRem=rem(counts.rock), cRem=rem(counts.crystal), mRem=rem(counts.metal);
  const rockPer=share(counts.rock), crystalPer=share(counts.crystal), metalPer=share(counts.metal);
  const clustersPer=Math.floor(share(extraCluster)); const giantsPer=Math.max(0,Math.floor(counts.giants/fields));

  for(let f=0; f<fields; f++){
    const rocks=rockPer+(rRem-->0?1:0);
    const crystalsBase=crystalPer+(cRem-->0?1:0);
    const crystals = (f===0)?Math.floor(crystalsBase*0.5):crystalsBase; // fewer at start
    const metals=metalPer+(mRem-->0?1:0);

    for(let i=0;i<clustersPer;i++){
      const P=posInField(f,true); const size=6+Math.pow(R(),2)*40; const hp=Math.round(size*1.2+30);
      spawnTo(choosePoolByMat(matRock),P,size,hp,makeColRock(),'rock'); if((i&255)===0){ progress&&progress('Clusters…'); await nextFrame(); }
    }
    for(let i=0;i<rocks;i++){
      const P=posInField(f,false); const size=6+Math.pow(R(),2)*40; const hp=Math.round(size*1.2+30);
      spawnTo(choosePoolByMat(matRock),P,size,hp,makeColRock(),'rock'); if((i&511)===0){ progress&&progress('Rocks…'); await nextFrame(); }
    }
    for(let i=0;i<crystals;i++){
      const P=(R()<0.35)?posInField(f,true):posInField(f,false); const size=5+Math.pow(R(),1.8)*28; const hp=Math.round(size*1.0+24);
      spawnTo(choosePoolByMat(matCrystal),P,size,hp,makeColCrystal(),'crystal'); if((i&511)===0){ progress&&progress('Crystals…'); await nextFrame(); }
    }
    for(let i=0;i<metals;i++){
      const P=(R()<0.25)?posInField(f,true):posInField(f,false); const size=8+Math.pow(R(),2.2)*36; const hp=Math.round(size*1.35+40);
      spawnTo(choosePoolByMat(matMetal),P,size,hp,makeColMetal(),'metal'); if((i&511)===0){ progress&&progress('Metals…'); await nextFrame(); }
    }
    for(let i=0;i<giantsPer;i++){
      const P=posInField(f,false); const size=60+R()*70; const hp=Math.round(size*1.9+160);
      spawnTo(choosePoolByMat(matRock),P,size,hp,makeColRock(),'rock');
    }
  }
  finalizePools();
  buildFieldFX(START_CENTER, START_CLEAR_R);
}

/* ---------- Drops + PERF: pooled flares ---------- */
function resetDrops(){
  if(DROPS.inst){ scene.remove(DROPS.inst); DROPS.inst.geometry.dispose(); DROPS.inst.material.dispose(); }
  DROPS.count=0; DROPS.data=[]; DROPS.geo=new THREE.OctahedronGeometry(1,0);
  DROPS.mat = new THREE.MeshBasicMaterial({vertexColors:true, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false});
  DROPS.cap=(quality==='ultra'?3200:2200); // lower cap for perf
  DROPS.inst=new THREE.InstancedMesh(DROPS.geo,DROPS.mat,DROPS.cap);
  DROPS.inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  DROPS.inst.instanceColor=new THREE.InstancedBufferAttribute(new Float32Array(DROPS.cap*3),3);
  scene.add(DROPS.inst);
}
const glowTexLoot=makeGlowTexture(128,0.0,0.55,'rgba(255,240,140,1)');
const LOOT={ pool:[], reverse:[], assigned:new Map(), budget:0, last:0 };
function destroyLootFlares(){ for(const s of LOOT.pool){ scene.remove(s); s.material.map.dispose(); s.material.dispose(); } LOOT.pool.length=0; LOOT.reverse.length=0; LOOT.assigned.clear(); }
function setupLootFlares(){
  destroyLootFlares();
  LOOT.budget = (quality==='ultra') ? 220 : 140;
  for(let i=0;i<LOOT.budget;i++){
    const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexLoot,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false,opacity:0.85}));
    sp.visible=false; sp.renderOrder=1; scene.add(sp); LOOT.pool.push(sp); LOOT.reverse[i]=undefined;
  }
}
function spawnDrop(pos,value,color,scale=1.4){
  if(DROPS.count>=DROPS.cap) return;
  const id=DROPS.count++, vel=new THREE.Vector3((Math.random()-0.5)*3,(Math.random()-0.5)*3,(Math.random()-0.5)*3);
  DROPS.data[id]={pos:pos.clone(),vel,value,alive:true,color,scale,flareSlot:-1};
  const m=new THREE.Matrix4().compose(DROPS.data[id].pos,new THREE.Quaternion(),new THREE.Vector3(scale,scale,scale));
  DROPS.inst.setMatrixAt(id,m); DROPS.inst.setColorAt(id,new THREE.Color(color)); DROPS.inst.count=DROPS.count;
  DROPS.inst.instanceMatrix.needsUpdate=true; DROPS.inst.instanceColor.needsUpdate=true;
}
function addDropsOnDestroy(a){
  const baseScale=clamp(a.size*0.5,1.5,24), count=2+(a.size>30?1:0)+(a.size>70?1:0);
  for(let i=0;i<count;i++){
    const off=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(a.size*0.25);
    const pos=new THREE.Vector3(a.x,a.y,a.z).add(off);
    const col = (a.type==='crystal') ? 0xa3d1ff : (a.type==='metal' ? 0xffd54a : 0xc0c0ff);
    spawnDrop(pos,Math.round(baseScale*12+Math.random()*20),col,baseScale);
  }
}
function maybeChipLoot(p){ if(Math.random()<0.2) spawnDrop(p,Math.round(10+Math.random()*10),0xc0c0ff,1.2); }
function reassignLootFlares(dt){
  LOOT.last += dt; if(LOOT.last<0.15) return; LOOT.last=0;
  const cand=[];
  const sx=ship.pos.x, sy=ship.pos.y, sz=ship.pos.z; const maxD2=2600*2600;
  for(let i=0;i<DROPS.count;i++){
    const d=DROPS.data[i]; if(!d||!d.alive) continue;
    const dx=sx-d.pos.x, dy=sy-d.pos.y, dz=sz-d.pos.z; const d2=dx*dx+dy*dy+dz*dz;
    if(d2<=maxD2) cand.push([d2,i]);
  }
  cand.sort((a,b)=>a[0]-b[0]);
  const selected=new Set(); const cap=Math.min(LOOT.pool.length,cand.length);
  for(let k=0;k<cap;k++) selected.add(cand[k][1]);

  // Release those not selected
  for(const [dropIdx, poolIdx] of LOOT.assigned){
    if(!selected.has(dropIdx)){
      const sp=LOOT.pool[poolIdx]; sp.visible=false;
      LOOT.assigned.delete(dropIdx); LOOT.reverse[poolIdx]=undefined;
      const d=DROPS.data[dropIdx]; if(d) d.flareSlot=-1;
    }
  }
  // Assign new ones
  const avail=[]; for(let i=0;i<LOOT.pool.length;i++){ if(LOOT.reverse[i]==null) avail.push(i); }
  for(const idx of selected){
    const d=DROPS.data[idx]; if(!d) continue;
    if(LOOT.assigned.has(idx)) continue;
    if(!avail.length) break;
    const pidx=avail.pop(); LOOT.assigned.set(idx,pidx); LOOT.reverse[pidx]=idx; d.flareSlot=pidx;
    const sp=LOOT.pool[pidx]; sp.position.copy(d.pos); sp.scale.setScalar(Math.min(32,d.scale*1.8)); sp.visible=true;
  }
}

/* ---------- NPC: Trawlers (unchanged logic) ---------- */
function makeTrawlerMesh(seed){
  const g=new THREE.Group();
  const hull=new THREE.Mesh(new THREE.CapsuleGeometry(10,60,6,12), new THREE.MeshStandardMaterial({color:0x3a4d62, metalness:0.7, roughness:0.45}));
  hull.rotation.z=Math.PI/2; g.add(hull);
  const podMat=new THREE.MeshStandardMaterial({color:0x7088a0, metalness:0.6, roughness:0.5});
  for(let i=0;i<6;i++){ const pod=new THREE.Mesh(new THREE.BoxGeometry(12,10,10), podMat.clone()); pod.position.set(-20+i*10, (i%2?12:-12), 0); g.add(pod); }
  const tTex=makeGlowTexture(256,0.0,0.7,'rgba(120,200,255,1)');
  const t1=new THREE.Sprite(new THREE.SpriteMaterial({map:tTex,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false,opacity:0.7})), t2=t1.clone();
  t1.position.set(40, 7, 0); t2.position.set(40,-7,0); t1.scale.set(22,22,1); t2.scale.set(22,22,1); g.add(t1,t2);
  g.frustumCulled=false; return g;
}
function spawnTrawlers(){
  for(let i=TRAWLERS.length-1;i>=0;i--){ scene.remove(TRAWLERS[i].mesh); }
  TRAWLERS.length=0;
  const R=rng(seed^0x5151); const count=(quality==='ultra')?2:2; // kept small for perf
  for(let i=0;i<count;i++){
    const fIdx=1+Math.floor(R()*Math.max(1,FIELDS.length-1)); const from=FIELDS[fIdx].center.clone();
    const to=(R()<0.5)?STATION.pos.clone():FIELDS[Math.floor(R()*FIELDS.length)].center.clone();
    const mesh=makeTrawlerMesh(seed^i);
    const pos=from.clone().add(new THREE.Vector3((R()*2-1)*120,(R()*2-1)*60,(R()*2-1)*120));
    mesh.position.copy(pos); scene.add(mesh);
    TRAWLERS.push({mesh,pos,vel:new THREE.Vector3(),hp:1200+(R()*400|0),radius:20,from,to,speed:120+(R()*30),cargo:300+Math.floor(R()*600),dying:false});
  }
}
function destroyTrawler(t){
  if(t.dying) return; t.dying=true; spawnExplosion(t.pos,6);
  const n=8+Math.floor(Math.random()*8);
  for(let i=0;i<n;i++){ const off=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(40);
    const p=t.pos.clone().add(off); const val=Math.round(t.cargo/n*(0.6+Math.random()*0.8));
    spawnDrop(p,val,0xffd54a,4+Math.random()*3);
  }
  scene.remove(t.mesh); const idx=TRAWLERS.indexOf(t); if(idx>=0) TRAWLERS.splice(idx,1);
}
function updateTrawlers(dt){
  for(const t of TRAWLERS){
    const dir=t.to.clone().sub(t.pos); const dist=dir.length();
    if(dist<80){ const tmp=t.from; t.from=t.to; t.to=tmp; t.cargo=300+Math.floor(Math.random()*600); }
    else { dir.normalize(); t.vel.lerp(dir.multiplyScalar(t.speed), 0.6*dt); t.pos.addScaledVector(t.vel,dt); t.mesh.position.copy(t.pos);
      const look=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), t.vel.clone().normalize()); if(isFinite(look.x)) t.mesh.quaternion.slerp(look,0.15); }
  }
}

/* ---------- FX & Weapons ---------- */
const FX={ group:new THREE.Group() }; scene.add(FX.group);
function makeBeamGlow(size=96,inner=0,outer=1,col='rgba(130,200,255,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer); g.addColorStop(0,col); g.addColorStop(1,'rgba(0,0,0,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}
const glowTexBlue = makeBeamGlow(128,0,0.5,'rgba(130,200,255,1)');
const glowTexOrange = makeBeamGlow(128,0,0.5,'rgba(255,180,80,1)');

function spawnExplosion(pos,scale){
  const g=new THREE.SphereGeometry(1,10,8), m=new THREE.MeshBasicMaterial({color:0xffaa55,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending,depthWrite:false});
  const s=new THREE.Mesh(g,m); s.position.copy(pos); s.scale.setScalar(0.5); s.userData.t=0; s.userData.life=0.4; s.userData.scale=scale*0.08+0.6; FX.group.add(s);
  const dist=pos.distanceTo(ship.pos); const pct=THREE.MathUtils.clamp(1-dist/1000,0,1);
  if(pct>0){ addShake(0.6*pct, 0.25+0.2*pct); AUD.boom(); screenFlash(0.12*pct); triggerKick(1.2*pct); }
}

/* ---- Laser visibility (no depth test) ---- */
function createLaserBeam(start,end){
  const dir=end.clone().sub(start), len=Math.max(0.001,dir.length()), dirN=dir.clone().normalize();
  const gCore=new THREE.CylinderGeometry(1.3,1.3,1,18,1,true);
  const mCore=new THREE.MeshBasicMaterial({color:0x88ccff,transparent:true,opacity:0.95,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false});
  const core=new THREE.Mesh(gCore,mCore);
  const gGlow=new THREE.CylinderGeometry(2.6,2.6,1,18,1,true);
  const mGlow=new THREE.MeshBasicMaterial({color:0x66aaff,transparent:true,opacity:0.35,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false});
  const glow=new THREE.Mesh(gGlow,mGlow);
  const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0),dirN);
  core.quaternion.copy(q); glow.quaternion.copy(q);
  const startSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,depthTest:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  const endSprite  =new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,depthTest:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  startSprite.scale.set(7,7,1); endSprite.scale.set(9,9,1);
  core.frustumCulled=false; glow.frustumCulled=false; startSprite.frustumCulled=false; endSprite.frustumCulled=false;
  core.renderOrder=10; glow.renderOrder=10; startSprite.renderOrder=11; endSprite.renderOrder=11;
  scene.add(core,glow,startSprite,endSprite);
  return {start:start.clone(),dir:dirN,len,mesh:core,outer:glow,startGlow:startSprite,endGlow:endSprite,t:0,life:0.22,growTime:0.06};
}
function updateBeam(b,dt){
  b.t+=dt; const p=Math.min(1,b.t/b.growTime), L=b.len*p, mid=b.start.clone().addScaledVector(b.dir,L*0.5);
  b.mesh.position.copy(mid); b.outer.position.copy(mid); b.mesh.scale.set(1,L,1); b.outer.scale.set(1,L,1);
  b.startGlow.position.copy(b.start); b.endGlow.position.copy(b.start.clone().addScaledVector(b.dir,L));
  const f=(b.t<=b.growTime)?1:Math.max(0,1-(b.t-b.growTime)/(b.life-b.growTime));
  b.mesh.material.opacity=0.95*f; b.outer.material.opacity=0.35*f; b.startGlow.material.opacity=0.95*f; b.endGlow.material.opacity=0.95*f;
}
function removeBeam(b){
  scene.remove(b.mesh,b.outer,b.startGlow,b.endGlow);
  b.mesh.geometry.dispose(); b.mesh.material.dispose(); b.outer.geometry.dispose(); b.outer.material.dispose(); b.startGlow.material.dispose(); b.endGlow.material.dispose();
}
function triggerKick(k){ fovKick=Math.min(4, fovKick + k); }
function screenFlash(a){ flashAmt=Math.min(1, flashAmt+a); }

/* ---------- Ray tests (allocation-free) ---------- */
const _tmpPoint=new THREE.Vector3();
function rayHitAsteroids(origin,dir,maxRange){
  const ox=origin.x, oy=origin.y, oz=origin.z, dx=dir.x, dy=dir.y, dz=dir.z;
  let bestT=Infinity,best=null;
  for(const a of AST.data){ if(!a.alive) continue;
    const lx=a.x-ox, ly=a.y-oy, lz=a.z-oz;
    const tca=lx*dx+ly*dy+lz*dz; if(tca<0) continue;
    const ll=lx*lx+ly*ly+lz*lz; const d2=ll - tca*tca; const rr=a.size*a.size; if(d2>rr) continue;
    const t0=tca - Math.sqrt(rr-d2); if(t0>0 && t0<bestT){ bestT=t0; best=a; }
  }
  if(best && bestT<=maxRange){ _tmpPoint.set(ox+dx*bestT, oy+dy*bestT, oz+dz*bestT); return {hit:true,t:bestT,kind:'asteroid',rock:best,point:_tmpPoint.clone()}; }
  _tmpPoint.set(ox+dx*maxRange, oy+dy*maxRange, oz+dz*maxRange); return {hit:false,t:maxRange,kind:null,rock:null,point:_tmpPoint.clone()};
}
function rayHitTrawlers(origin,dir,maxRange){
  const ox=origin.x, oy=origin.y, oz=origin.z, dx=dir.x, dy=dir.y, dz=dir.z;
  let bestT=Infinity,best=null;
  for(const s of TRAWLERS){
    const lx=s.pos.x-ox, ly=s.pos.y-oy, lz=s.pos.z-oz;
    const tca=lx*dx+ly*dy+lz*dz; if(tca<0) continue;
    const ll=lx*lx+ly*ly+lz*lz; const d2=ll - tca*tca; const rr=s.radius*s.radius; if(d2>rr) continue;
    const t0=tca - Math.sqrt(rr-d2); if(t0>0 && t0<bestT){ bestT=t0; best=s; }
  }
  if(best && bestT<=maxRange){ _tmpPoint.set(ox+dx*bestT, oy+dy*bestT, oz+dz*bestT); return {hit:true,t:bestT,kind:'trawler',ship:best,point:_tmpPoint.clone()}; }
  _tmpPoint.set(ox+dx*maxRange, oy+dy*maxRange, oz+dz*maxRange); return {hit:false,t:maxRange,kind:null,ship:null,point:_tmpPoint.clone()};
}
function rayHitWorld(origin,dir,maxRange){
  const a=rayHitAsteroids(origin,dir,maxRange);
  const b=rayHitTrawlers(origin,dir,maxRange);
  if(a.hit && b.hit) return (a.t<b.t)?a:b;
  return (a.hit)?a:(b.hit?b:{hit:false,t:maxRange,kind:null,point:origin.clone().addScaledVector(dir,maxRange)});
}

/* ---------- Weapons ---------- */
function getReticleRay(){ const origin=camera.position.clone(); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); return {origin,dir}; }
function fireLaser(){
  const L=ship.laser; if(L.over||L._cd>0) return; L.heat+=L.shotHeat; if(L.heat>=100){ L.over=true; toast('Laser overheated!'); }
  L._cd=1/Math.max(3,ship.laser.rof);
  const {origin,dir}=getReticleRay(); const pick=rayHitWorld(origin,dir,ship.range); const endPoint=pick.point.clone();
  const startL=hardpointWorld(HP_LOCAL.laserL), startR=hardpointWorld(HP_LOCAL.laserR);
  LASER_BEAMS.push(createLaserBeam(startL,endPoint)); LASER_BEAMS.push(createLaserBeam(startR,endPoint)); triggerKick(1.1); screenFlash(0.05); AUD.zap();
  if(pick.hit){
    if(pick.kind==='asteroid'){ pick.rock.hp-=ship.laser.dmg; maybeChipLoot(endPoint); if(pick.rock.hp<=0) destroyAsteroid(pick.rock); }
    else if(pick.kind==='trawler'){ pick.ship.hp -= ship.laser.dmg*0.6; if(pick.ship.hp<=0) destroyTrawler(pick.ship); }
  }
}
function fireMissile(){
  const M=ship.missile; if(M.over||M._cd>0) return; M.heat+=M.shotHeat; if(M.heat>=100){ M.over=true; toast('Missiles overheated!'); }
  M._cd=M.reload; const {dir}=getReticleRay(); spawnMissile(dir); triggerKick(1.6); screenFlash(0.06);
}
function spawnMissile(dir){
  const nose=hardpointWorld(HP_LOCAL.missile);
  const core=new THREE.Mesh(new THREE.SphereGeometry(0.7,14,12), new THREE.MeshBasicMaterial({color:0xffcc88,transparent:true,opacity:1,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false}));
  const glow=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false,opacity:0.9}));
  glow.scale.set(7,7,1); const group=new THREE.Group(); group.add(glow,core); group.position.copy(nose); scene.add(group);
  MISSILES.push({pos:nose.clone(),vel:dir.clone().multiplyScalar(180),life:10,mesh:group,trailT:0});
}

/* ---------- Station ---------- */
const STATION={ group:null, pos:new THREE.Vector3(0,0,-11000), arm:null };
function buildStation(){
  if(STATION.group){ scene.remove(STATION.group); }
  const g=new THREE.Group();
  const core=new THREE.Mesh(new THREE.CylinderGeometry(30,30,160,24,1,true), new THREE.MeshStandardMaterial({color:0x26313f,metalness:0.8,roughness:0.4}));
  const ring=new THREE.Mesh(new THREE.TorusGeometry(140,10,18,72), new THREE.MeshStandardMaterial({color:0x3a4d62,metalness:0.7,roughness:0.45}));
  ring.rotation.x=Math.PI/2; const arm=new THREE.Group();
  for(let i=0;i<4;i++){ const p=new THREE.Mesh(new THREE.BoxGeometry(8,180,2), new THREE.MeshStandardMaterial({color:0x88aadd,metalness:0.2,roughness:0.8,emissive:0x0a1422,emissiveIntensity:0.25}));
    p.position.y=100; p.rotation.z=Math.PI/2; const h=new THREE.Group(); h.rotation.y=i*Math.PI/2; h.add(p); arm.add(h); }
  const beacon=new THREE.Sprite(new THREE.SpriteMaterial({map:makeGlowTexture(256,0.0,0.85,'rgba(120,255,200,1)'),transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false,opacity:0.7}));
  beacon.scale.set(160,160,1);
  g.add(core, ring, arm, beacon); g.position.copy(STATION.pos); g.frustumCulled=false; scene.add(g);
  STATION.group=g; STATION.arm=arm;
}
let dockPrompt=false, docked=false;
function refineAtStation(){
  const mult = 1 + 0.12*(upgrades.yield-1);
  const bonus=Math.round(ship.cargo*8*mult);
  if(bonus>0){ ship.credits+=bonus; ship.cargo=0; toast(`Refined: +${bonus} cr`); save(); updateUI(); addShake(0.3,0.35); screenFlash(0.12); }
}
function openDockPanel(){
  unlockPointer(); setPaused(true,'dock'); docked=true;
  ui.dsCredits.textContent = (ship.credits|0);
  ui.dsCargo.textContent = `${ship.cargo|0}/${ship.cargoCap|0}`;
  ui.dsSpeed.textContent = ship.vel.length().toFixed(1);
  ui.dockMask.style.display='flex';
  ui.dockShopMount.appendChild(ui.shop);
  ui.shop.style.display='block';
}
function closeDockPanel(){
  ui.dockMask.style.display='none'; docked=false; document.body.appendChild(ui.shop); ui.shop.style.display='none';
  if(pauseReason==='dock'){ setPaused(false,null); if(fpsOn) ui.fps.style.display='block'; }
}
byId('dockRefine').addEventListener('click',()=>refineAtStation());
byId('dockUndock').addEventListener('click',()=>closeDockPanel());
function updateStation(dt){
  if(!STATION.group) return;
  STATION.arm.rotation.y += dt*0.25;
  const dist=ship.pos.distanceTo(STATION.pos);
  ui.ref.textContent=isFinite(dist)?dist.toFixed(0):'—';
  if(!docked){
    if(dist<180){
      if(!dockPrompt){ toast('Press C to Dock (Station)'); dockPrompt=true; }
      if(keys['KeyC']) openDockPanel();
    } else dockPrompt=false;
  }
}

/* ---------- Scanner pips ---------- */
const SCAN={ group:new THREE.Group(), sprites:[], last:0 }; scene.add(SCAN.group);
function makePip(color){
  const s=new THREE.Sprite(new THREE.SpriteMaterial({map:makeGlowTexture(96,0.3,1.0,`rgba(${color},1)`),transparent:true,blending:THREE.AdditiveBlending,depthTest:false,depthWrite:false,opacity:0.8}));
  s.scale.set(10,10,1); s.visible=false; SCAN.group.add(s); return s;
}
function ensurePips(n){ while(SCAN.sprites.length<n){ const c=(SCAN.sprites.length&1)?'255,200,120':'150,230,255'; SCAN.sprites.push(makePip(c)); } }
function updateScan(dt){
  SCAN.last+=dt; if(SCAN.last<0.75) return; SCAN.last=0;
  const maxPips=20 + upgrades.scan*12; ensurePips(maxPips);
  const center=ship.pos; const cand=[];
  for(const a of AST.data){ if(!a.alive||a.type==='rock') continue;
    const dx=a.x-center.x, dy=a.y-center.y, dz=a.z-center.z; const d2=dx*dx+dy*dy+dz*dz; if(d2>ship.scannerRange*ship.scannerRange) continue; cand.push([d2,{x:a.x,y:a.y,z:a.z,size:a.size}]); }
  for(const s of TRAWLERS){ const dx=s.pos.x-center.x, dy=s.pos.y-center.y, dz=s.pos.z-center.z; const d2=dx*dx+dy*dy+dz*dz; if(d2>ship.scannerRange*ship.scannerRange) continue; cand.push([d2,{x:s.pos.x,y:s.pos.y,z:s.pos.z,size:s.radius*1.4}]); }
  cand.sort((A,B)=>A[0]-B[0]); for(let i=0;i<SCAN.sprites.length;i++) SCAN.sprites[i].visible=false;
  const used=Math.min(maxPips, cand.length);
  for(let i=0;i<used;i++){ const a=cand[i][1], sp=SCAN.sprites[i]; sp.visible=true; sp.position.set(a.x,a.y,a.z); sp.scale.setScalar(6+Math.min(24,a.size*0.3)); }
}

/* ---------- UI ---------- */
function updateUI(){
  ui.spd.textContent=ship.vel.length().toFixed(1);
  ui.range.textContent=ship.range.toFixed(0);
  ui.credits.textContent=ship.credits|0;
  ui.cargo.textContent=ship.cargo|0;
  ui.cap.textContent=ship.cargoCap|0;
  ui.thrustPct.textContent = Math.round(MOUSE.throttle*100);
  ui.barLaser.style.width=clamp(ship.laser.heat,0,100)+'%';
  ui.barMiss.style.width =clamp(ship.missile.heat,0,100)+'%';
  ui.barBoost.style.width = clamp((ship.boost.val/ship.boost.cap)*100,0,100)+'%';
  ui.barLaser.classList.toggle('warn', ship.laser.heat>85);
  ui.barMiss.classList.toggle('warn', ship.missile.heat>85);
  refreshShop();
}

/* ---------- Target indicator ---------- */
const TARGET={ group:null, rock:null };
function ensureTargetVisual(){
  if(TARGET.group) return;
  const ringGeo=new THREE.RingGeometry(0.92, 1.03, 64);
  const ringMat=new THREE.MeshBasicMaterial({color:0x68ffb0, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false});
  const ring=new THREE.Mesh(ringGeo, ringMat);
  const fillGeo=new THREE.CircleGeometry(0.92, 48);
  const fillMat=new THREE.MeshBasicMaterial({color:0x68ffb0, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false, side:THREE.DoubleSide});
  const fill=new THREE.Mesh(fillGeo, fillMat);
  const g=new THREE.Group(); g.add(fill,ring); g.visible=false; g.renderOrder=12; scene.add(g); TARGET.group=g;
}
function showTarget(target){
  ensureTargetVisual();
  if(!target){ TARGET.group.visible=false; ui.tgtHud.style.display='none'; return; }
  const pos = target.kind==='trawler' ? target.ship.pos : new THREE.Vector3(target.rock.x,target.rock.y,target.rock.z);
  const size= target.kind==='trawler' ? target.ship.radius*1.8 : target.rock.size*1.04;

  TARGET.group.visible=true; TARGET.group.position.copy(pos);
  const look=new THREE.Vector3().subVectors(camera.position,pos).normalize();
  TARGET.group.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), look);
  TARGET.group.scale.setScalar(size);

  ui.tgtHud.style.display='block';
  ui.tgtHud.textContent = (target.kind==='trawler')
    ? `trawler · ${Math.max(0,target.ship.hp|0)} HP · ${camera.position.distanceTo(pos).toFixed(0)} m`
    : `${target.rock.type||'asteroid'} · ${Math.max(0,target.rock.hp|0)} HP · ${camera.position.distanceTo(pos).toFixed(0)} m`;
}

/* ---------- Nav (edge clamp + smoothing + cycle) ---------- */
const NAV={ px:innerWidth/2, py:40, targetIdx:0,
  currentPos(){ if(this.targetIdx===0) return STATION.pos; const f=FIELDS[this.targetIdx-1]; return f?f.center:STATION.pos; },
  currentName(){ return this.targetIdx===0?'STATION':('FIELD '+String.fromCharCode(65+this.targetIdx-1)); },
  nextTarget(){ const max=1+FIELDS.length; this.targetIdx=(this.targetIdx+1)%max; toast('Nav → '+this.currentName()); },
};
function updateNavHUD(worldPos,dt){
  const w=innerWidth, h=innerHeight, pad=22;
  const padNdcX = pad/(w*0.5), padNdcY = pad/(h*0.5);

  const cp = worldPos.clone().applyMatrix4(camera.matrixWorldInverse);
  const behind = cp.z > 0;
  let v = worldPos.clone().project(camera);
  if(behind){ v.x = -v.x; v.y = -v.y; }

  const m = Math.max(Math.abs(v.x), Math.abs(v.y), 1e-6);
  v.x /= m; v.y /= m;
  v.x = clamp(v.x, -1+padNdcX, 1-padNdcX);
  v.y = clamp(v.y, -1+padNdcY, 1-padNdcY);

  const targetX = (v.x*0.5+0.5)*w;
  const targetY = (-v.y*0.5+0.5)*h;

  const alpha = 1 - Math.pow(0.001, dt*60*0.9);
  NAV.px = lerp(NAV.px, targetX, alpha);
  NAV.py = lerp(NAV.py, targetY, alpha);

  const dist = ship.pos.distanceTo(worldPos);
  if(docked || dist<80){ ui.nav.style.display='none'; return; }

  ui.nav.style.display='flex';
  ui.nav.style.left = `${NAV.px}px`;
  ui.nav.style.top  = `${NAV.py}px`;
  ui.navName.textContent = NAV.currentName();

  const ang=Math.atan2(NAV.py-h/2, NAV.px-w/2) + Math.PI/2;
  ui.navArrow.style.transform = `rotate(${ang}rad)`;
  ui.navDist.textContent = dist.toFixed(0);
}

/* ---------- Loop + Dynamic Resolution ---------- */
const clock=new THREE.Clock();
let retTmr=0, lockTarget=null;
function addShake(amp,t){ shakeAmp=Math.max(shakeAmp,amp); shakeT=Math.max(shakeT,t); }
function applyCameraShake(dt){
  if(shakeT>0){ shakeT-=dt; const k=shakeT<=0?0:shakeAmp*(shakeT/(shakeT+0.08));
    camera.position.addScaledVector(new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize(), k*0.15); }
}
function updateScreenFX(dt){
  retTmr-=dt;
  if(retTmr<=0){
    retTmr=0.05;
    const {origin,dir}=getReticleRay();
    const pickA=rayHitWorld(origin,dir,ship.range);
    lockTarget = pickA.hit ? pickA : null; showTarget(lockTarget);
  }
  const root=document.documentElement.style;
  if(lockTarget){ root.setProperty('--ret','rgba(120,255,180,.95)'); root.setProperty('--retGlow','rgba(120,255,180,.65)'); root.setProperty('--retGlow2','rgba(120,255,180,.45)'); root.setProperty('--retScale','1.08'); }
  else { root.setProperty('--ret','rgba(173,216,255,.9)'); root.setProperty('--retGlow','rgba(120,180,255,.55)'); root.setProperty('--retGlow2','rgba(120,180,255,.35)'); root.setProperty('--retScale','1'); }
  fovKick = lerp(fovKick, 0, Math.min(1, dt*6)); camera.fov = baseFov + fovKick; camera.updateProjectionMatrix();
  flashAmt = lerp(flashAmt, 0, Math.min(1, dt*6)); ui.flash.style.opacity = flashAmt.toFixed(3);
}
let fpsAccum=0, fpsFrames=0, fpsEMA=60, dprTimer=0;
function updateFPS(dt){
  if(paused) return;
  fpsAccum+=dt; fpsFrames++; const inst=1/dt; fpsEMA = fpsEMA*0.9 + inst*0.1;
  if(fpsOn && fpsAccum>=0.25){ const fps=(fpsFrames/fpsAccum), ms=(1000/fps); ui.fps.textContent=`${fps.toFixed(0)} fps · ${ms.toFixed(1)} ms · res ×${currentDPR.toFixed(2)}`; fpsAccum=0; fpsFrames=0; }
}
function adjustResolution(dt){
  if(paused) return;
  dprTimer+=dt; if(dprTimer<1.0) return; dprTimer=0;
  if(fpsEMA<45 && currentDPR>DPR_MIN){ currentDPR=Math.max(DPR_MIN,currentDPR-0.05); renderer.setPixelRatio(currentDPR); renderer.setSize(innerWidth,innerHeight,false); }
  else if(fpsEMA>58 && currentDPR<DPR_MAX){ currentDPR=Math.min(DPR_MAX,currentDPR+0.05); renderer.setPixelRatio(currentDPR); renderer.setSize(innerWidth,innerHeight,false); }
}

function handleInput(dt){
  if(paused) return;
  let yaw=((keys['KeyA']?1:0)-(keys['KeyD']?1:0))*ship.yawRate*dt;
  let pitch=((keys['KeyW']?1:0)-(keys['KeyS']?1:0))*ship.pitchRate*dt;
  let roll=((keys['KeyQ']?1:0)-(keys['KeyE']?1:0))*ship.rollRate*dt;
  if(Settings.mouseAim && MOUSE.locked){
    if(MOUSE.mmb){ roll += MOUSE.roll; } else { yaw += MOUSE.yaw; }
    pitch += MOUSE.pitch; MOUSE.yaw=0; MOUSE.pitch=0; MOUSE.roll=0;
  }
  const qYaw=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),yaw);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),pitch);
  const qRoll=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),-roll);
  ship.quat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat);
  const up =new THREE.Vector3(0,1,0).applyQuaternion(ship.quat);
  const right=new THREE.Vector3(1,0,0).applyQuaternion(ship.quat);

  const throttle=MOUSE.throttle;
  const thrustFKeys=(keys['ArrowUp']?1:0)-(keys['ArrowDown']?1:0);
  const forwardInput=clamp(throttle + thrustFKeys, -1, 1);

  const thrustX=(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
  const thrustY=(keys['KeyR']?1:0)-(keys['KeyF']?1:0);

  const boosting=(keys['ShiftLeft']||keys['ShiftRight']) && (ship.boost.val>0.01);
  const mult=boosting?ship.boost.mult:1.0;
  if(boosting){ ship.boost.val=Math.max(0, ship.boost.val - dt); triggerKick(0.3); }
  else { ship.boost.val=Math.min(ship.boost.cap, ship.boost.val + ship.boost.regen*dt); }

  ship.vel.addScaledVector(fwd,forwardInput*ship.thrust*mult*dt);
  ship.vel.addScaledVector(right,thrustX*ship.strafe*mult*dt);
  ship.vel.addScaledVector(up,thrustY*ship.lift*mult*dt);

  if(keys['KeyZ']) ship.vel.multiplyScalar(Math.pow(1-ship.brakeCoeff,dt*60)); else ship.vel.multiplyScalar(1-ship.dampingLin*dt);
  const spd=ship.vel.length(); if(spd>ship.maxSpeed*mult) ship.vel.multiplyScalar((ship.maxSpeed*mult)/spd);

  if(keys['Space'] || MOUSE.fireL) fireLaser();
  if(keys['KeyX']  || MOUSE.fireR) fireMissile();

  if(keys['KeyC'] && docked){ closeDockPanel(); }
}

function updateMissiles(dt){
  for(let i=MISSILES.length-1;i>=0;i--){
    const m=MISSILES[i];
    const {origin,dir}=getReticleRay(); const pick=rayHitWorld(origin,dir,1600);
    if(pick.hit){ const aim=pick.point.clone().sub(m.pos).normalize(); m.vel.lerp(aim.multiplyScalar(200), ship.seekStrength); }
    m.pos.addScaledVector(m.vel,dt); m.mesh.position.copy(m.pos); m.life-=dt;
    m.trailT=(m.trailT||0)+dt; if(m.trailT>0.03){ m.trailT=0; const s=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,depthTest:false,opacity:0.8})); s.position.copy(m.pos); s.scale.set(5,5,1); s.userData.t=0; s.userData.life=0.35; FX.group.add(s); }
    let hitAst=null; let hitShip=null;
    for(const a of AST.data){ if(!a.alive) continue; const dx=m.pos.x-a.x,dy=m.pos.y-a.y,dz=m.pos.z-a.z,r=a.size*1.15; if(dx*dx+dy*dy+dz*dz<=r*r){ hitAst=a; break; } }
    if(!hitAst){ for(const t of TRAWLERS){ const dx=m.pos.x-t.pos.x,dy=m.pos.y-t.pos.y,dz=m.pos.z-t.pos.z,r=t.radius*1.2; if(dx*dx+dy*dy+dz*dz<=r*r){ hitShip=t; break; } } }
    if(hitAst){ hitAst.hp-=ship.missile.dmg; if(hitAst.hp<=0) destroyAsteroid(hitAst); spawnExplosion(m.pos,2.4); scene.remove(m.mesh); MISSILES.splice(i,1); }
    else if(hitShip){ hitShip.hp-=ship.missile.dmg*1.4; if(hitShip.hp<=0) destroyTrawler(hitShip); spawnExplosion(m.pos,3.0); scene.remove(m.mesh); MISSILES.splice(i,1); }
    else if(m.life<=0){ scene.remove(m.mesh); MISSILES.splice(i,1); }
  }
}

/* ---- Drops update (reused temps; pooled flares) ---- */
const _mtx=new THREE.Matrix4(), _toShip=new THREE.Vector3();
function updateDrops(dt){
  const sx=ship.pos.x, sy=ship.pos.y, sz=ship.pos.z;
  for(let i=0;i<DROPS.count;i++){
    const d=DROPS.data[i]; if(!d||!d.alive) continue;
    d.pos.addScaledVector(d.vel,dt); d.vel.multiplyScalar(0.992);

    // update flare sprite if assigned
    if(d.flareSlot>=0){ const sp=LOOT.pool[d.flareSlot]; sp.position.copy(d.pos); sp.scale.setScalar(Math.min(32,d.scale*1.8)); }

    _toShip.set(sx-d.pos.x, sy-d.pos.y, sz-d.pos.z);
    const dist=_toShip.length();
    const magnetBase = 30 + (upgrades.magnet-1)*12;
    const range = magnetBase + d.scale*5.0;
    if(dist<range){ d.vel.add(_toShip.multiplyScalar(((magnetBase*1.4)+d.scale)*dt/dist)); }
    const pickupR = 6 + d.scale*0.6;
    if(dist<pickupR){
      d.alive=false; ship.credits+=d.value; ship.cargo=Math.min(ship.cargoCap,ship.cargo+1); toast('+'+d.value+' cr'); AUD.pickup();
      if(d.flareSlot>=0){ const pidx=d.flareSlot; const sp=LOOT.pool[pidx]; sp.visible=false; LOOT.assigned.delete(i); LOOT.reverse[pidx]=undefined; d.flareSlot=-1; }
      _mtx.compose(new THREE.Vector3(999999,999999,999999), new THREE.Quaternion(), new THREE.Vector3(0.0001,0.0001,0.0001));
      DROPS.inst.setMatrixAt(i,_mtx); DROPS.inst.instanceMatrix.needsUpdate=true; updateUI(); save();
    } else {
      _mtx.compose(d.pos, new THREE.Quaternion(), new THREE.Vector3(d.scale,d.scale,d.scale));
      DROPS.inst.setMatrixAt(i,_mtx);
    }
  }
  DROPS.inst.instanceMatrix.needsUpdate=true;
}

function updateFX(dt){
  for(let i=FX.group.children.length-1;i>=0;i--){
    const s=FX.group.children[i]; s.userData.t=(s.userData.t||0)+dt; const t=s.userData.t/(s.userData.life||0.35);
    if(s.isSprite){ s.material.opacity=0.8*(1-t); s.scale.setScalar(THREE.MathUtils.lerp(5,2.2,t)); }
    else { s.scale.setScalar(THREE.MathUtils.lerp(0.5,s.userData.scale||1,t)); s.material.opacity=0.9*(1-t); }
    if(t>=1){ FX.group.remove(s); s.material?.dispose?.(); s.geometry?.dispose?.(); }
  }
  for(let i=LASER_BEAMS.length-1;i>=0;i--){ const b=LASER_BEAMS[i]; updateBeam(b,dt); if(b.t>=b.life){ removeBeam(b); LASER_BEAMS.splice(i,1); } }
}

function loop(){
  const dt=Math.min(0.033,clock.getDelta());
  handleInput(dt);

  if(!paused){
    ship.pos.addScaledVector(ship.vel,dt);
    const eye=eyeLocal.clone().applyQuaternion(ship.quat);
    camera.position.copy(ship.pos).add(eye); camera.quaternion.copy(ship.quat);

    updateTrawlers(dt);
    applyCameraShake(dt); updateScreenFX(dt); updateScan(dt); updateStation(dt);

    shipGroup.position.copy(ship.pos); shipGroup.quaternion.copy(ship.quat);

    ship.laser._cd=Math.max(0,ship.laser._cd-dt); ship.laser.heat=Math.max(0,ship.laser.heat-ship.laser.cooldown*dt); if(ship.laser.over&&ship.laser.heat<=35){ ship.laser.over=false; toast('Laser ready'); }
    ship.missile._cd=Math.max(0,ship.missile._cd-dt); ship.missile.heat=Math.max(0,ship.missile.heat-ship.missile.cooldown*dt); if(ship.missile.over&&ship.missile.heat<=35){ ship.missile.over=false; toast('Missiles ready'); }

    updateMissiles(dt); updateDrops(dt); reassignLootFlares(dt); updateFX(dt);
    sun.position.copy(ship.pos).add(new THREE.Vector3(1,0.2,0.3).multiplyScalar(30000));
    updateFPS(dt); adjustResolution(dt);
  }

  updateNavHUD(NAV.currentPos(), dt);
  updateUI(); renderer.render(scene,camera); requestAnimationFrame(loop);
}

/* ---------- Quality / Seed ---------- */
function setQuality(q){ quality=q; Settings.quality=q; saveSettings(); ui.qual.textContent=(q==='ultra')?'Ultra':'High'; buildWorldAsync(seed); }
function newSeed(){ seed=(seed*1664525+1013904223)>>>0; buildWorldAsync(seed); }

/* ---------- Build World (async with loader) ---------- */
async function buildWorldAsync(s){
  Loader.show('Generating sector…'); Loader.pct(0.02); Loader.sub('Clearing old objects');

  for(const b of LASER_BEAMS){ removeBeam(b); } LASER_BEAMS.length=0;
  for(let i=MISSILES.length-1;i>=0;i--){ scene.remove(MISSILES[i].mesh); } MISSILES.length=0;
  for(let i=FX.group.children.length-1;i>=0;i--){ const n=FX.group.children[i]; FX.group.remove(n); n.geometry?.dispose?.(); n.material?.dispose?.(); }
  clearFieldFX(); destroyLootFlares(); await nextFrame();

  Loader.pct(0.10); Loader.sub('Drops & field…'); resetDrops(); setupLootFlares();

  Loader.pct(0.12); Loader.sub('Populating asteroid fields…'); await buildAsteroidsAsync(s, (msg)=>Loader.sub(msg)); Loader.pct(0.62);

  Loader.sub('Skydome'); if(skydome){ scene.remove(skydome); skydome.geometry.dispose(); skydome.material.dispose(); }
  skydome = makeSkydome(s ^ 0xDEADBEEF); scene.add(skydome); await nextFrame(); Loader.pct(0.70);

  Loader.sub('Seeding stars…'); if(stars) scene.remove(stars);
  const starCount = (quality==='ultra') ? 12000 : 8000; // reduced default counts
  stars = await makeStarfieldAsync(s^0x1234, starCount, 70000, (msg)=>Loader.sub(msg));
  scene.add(stars); Loader.pct(0.88);

  Loader.sub('Spinning up station…'); buildStation(); await nextFrame(); Loader.pct(0.92);

  Loader.sub('Launching trawlers…'); spawnTrawlers(); await nextFrame(); Loader.pct(0.96);

  const startField = FIELDS[0]?.center || new THREE.Vector3();
  ship.pos.copy(startField); ship.vel.set(0,0,0); ship.quat.identity();

  ship.laser.heat=0; ship.laser.over=false; ship.laser._cd=0; ship.missile.heat=0; ship.missile.over=false; ship.missile._cd=0;
  ship.boost.val = ship.boost.cap;
  MOUSE.throttle = 0;

  NAV.targetIdx = 0; ui.navName.textContent = NAV.currentName();

  ui.seed.textContent=s; ui.cap.textContent=ship.cargoCap; updateUI(); Loader.pct(1.0); Loader.hide();
  updateMouseHint();
}

/* ---------- Boot ---------- */
function onResize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize',onResize);
function attachGlobalShortcuts(){ document.addEventListener('keydown',(e)=>{ if(e.code==='KeyC' && docked){ closeDockPanel(); } if(e.code==='Escape' && ui.optMask.style.display==='flex'){ closeOptions(); } }); }

async function init(){
  loadSettings();
  baseFov = Settings.fov||75; quality = Settings.quality||quality;
  camera.fov=baseFov; camera.updateProjectionMatrix(); ui.qual.textContent=(quality==='ultra')?'Ultra':'High';

  bindShop(); load(); applyUpgrades();
  ui.seed.textContent=seed; refreshShop();
  scene.background=new THREE.Color(0x000000);
  attachGlobalShortcuts();
  await buildWorldAsync(seed);
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>

