<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AstroMiner — Reticle Aiming • Big Glowy Drops • WS Direct Pitch</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#eef}
  #app{position:fixed;inset:0;overflow:hidden}

  .hud{position:absolute;left:10px;top:10px;background:rgba(0,0,0,.45);padding:10px 12px;border-radius:12px;font-size:12px;backdrop-filter:blur(2px);line-height:1.25}
  .shop{position:absolute;right:10px;top:10px;background:rgba(0,0,0,.55);padding:10px 12px;border-radius:12px;min-width:260px;max-width:340px;font-size:12px}
  .shop h3{margin:0 0 6px;font-size:13px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0}
  .row button{background:#1f3b8f;border:0;color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}
  .row button[disabled]{opacity:.45;cursor:not-allowed}
  .k{opacity:.8}
  .bar{height:8px;background:#223;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(#66e,#44a);width:0}
  .bar.red>span{background:linear-gradient(#f66,#b22)}
  .cash{font-weight:700}
  .help{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:12px;max-width:560px}
  .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:10px;font-size:12px;display:none}
  .err{position:absolute;right:10px;bottom:10px;background:#300;color:#fee;padding:8px 10px;border-radius:10px;max-width:60ch;display:none;white-space:pre-wrap}

  /* Targeting reticle (center) */
  .ret{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;opacity:.9}
  .ret .ring{width:46px;height:46px;border:2px solid rgba(173,216,255,.9);border-radius:50%;box-shadow:0 0 18px rgba(120,180,255,.55) inset,0 0 22px rgba(120,180,255,.35)}
  .ret .lines{position:absolute;left:0;top:0;width:46px;height:46px}
  .ret .lines::before,.ret .lines::after{content:"";position:absolute;background:rgba(173,216,255,.9)}
  .ret .lines::before{left:50%;top:-10px;transform:translateX(-50%);width:2px;height:12px;box-shadow:0 44px 0 0 rgba(173,216,255,.9)}
  .ret .lines::after{top:50%;left:-10px;transform:translateY(-50%);height:2px;width:12px;box-shadow:44px 0 0 0 rgba(173,216,255,.9)}
</style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Seed:</b> <span id="uiSeed">0</span> · <b>Quality:</b> <span id="uiQual">High</span></div>
  <div style="margin-top:6px"><b>Speed:</b> <span id="uiSpd">0</span> m/s · <b>Range:</b> <span id="uiRange">0</span> m</div>
  <div style="margin-top:6px"><b>Laser Heat</b><div class="bar"><span id="barLaser"></span></div></div>
  <div style="margin-top:6px"><b>Missile Heat</b><div class="bar red"><span id="barMiss"></span></div></div>
  <div style="margin-top:6px"><b>Cargo</b>: <span id="uiCargo">0</span> / <span id="uiCap">100</span></div>
  <div><b>Credits</b>: <span class="cash" id="uiCredits">0</span></div>
</div>

<div class="shop" id="shop">
  <h3>Ship Upgrades</h3>
  <div class="row"><span>Laser Damage Lv <b id="lvLaserD">1</b></span><button id="buyLaserD">Buy (<span id="costLaserD">200</span>)</button></div>
  <div class="row"><span>Laser Cooling Lv <b id="lvLaserC">1</b></span><button id="buyLaserC">Buy (<span id="costLaserC">150</span>)</button></div>
  <div class="row"><span>Missile Damage Lv <b id="lvMissD">1</b></span><button id="buyMissD">Buy (<span id="costMissD">300</span>)</button></div>
  <div class="row"><span>Engine Thrust Lv <b id="lvThrust">1</b></span><button id="buyThrust">Buy (<span id="costThrust">250</span>)</button></div>
  <div class="row"><span>Turn Rate Lv <b id="lvTurn">1</b></span><button id="buyTurn">Buy (<span id="costTurn">200</span>)</button></div>
  <div class="row"><span>Cargo Magnet Lv <b id="lvMag">1</b></span><button id="buyMag">Buy (<span id="costMag">180</span>)</button></div>
  <hr style="border-color:#234">
  <div class="row"><span class="k">Lightning Beam</span><button id="unlockLightning">Locked (1200)</button></div>
  <div class="row"><span class="k">Mass Driver</span><button id="unlockMass">Locked (900)</button></div>
  <div class="row"><span class="k">Gravity Gun</span><button id="unlockGrav">Locked (1500)</button></div>
  <div style="margin-top:6px;opacity:.75">Toggle shop: <b>U</b> · Quality: <b>1</b>=High, <b>2</b>=Ultra · New Seed: <b>N</b></div>
</div>

<div class="help">
  <div><b>Controls</b> — Zero-G 6-DOF</div>
  <div>Pitch: <b>W/S</b> · Yaw: <b>A/D</b> · Roll: <b>Q/E</b></div>
  <div>Forward/Reverse: <b>↑/↓</b> · Strafe: <b>←/→</b> · Lift: <b>R/F</b></div>
  <div>Brake/Damp: <b>Z</b> · Laser: <b>Space</b> · Missile: <b>X</b></div>
</div>

<!-- Targeting reticle -->
<div class="ret"><div class="ring"></div><div class="lines"></div></div>

<div class="toast" id="toast"></div>
<div class="err" id="err"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

///////////////////////
// Utility & Seeding //
///////////////////////
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const rad=THREE.MathUtils.degToRad;
function rng(seed){ let s=seed>>>0; return ()=>{ s+=0x6D2B79F5; let t=Math.imul(s^(s>>>15),1|s); t^=t+Math.imul(t^(t>>>7),61|t); return ((t^(t>>>14))>>>0)/4294967296; }; }

/////////////////////
// Scene & Camera  //
/////////////////////
const app=document.getElementById('app');
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,240000);
camera.position.set(0,0,12);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:false});
renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setSize(innerWidth,innerHeight);
app.appendChild(renderer.domElement);

// subtle fill so asteroids read
scene.add(new THREE.AmbientLight(0x222233,0.95));
const sun=new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(1,0.2,0.3).multiplyScalar(30000); scene.add(sun);

/////////////////////
// Starfield & Sky //
/////////////////////
function makeStarfield(seed,count,spread=60000){
  const R=rng(seed), geo=new THREE.BufferGeometry(), pos=new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=spread*Math.pow(R(),0.25), th=R()*Math.PI*2, ph=Math.acos(2*R()-1);
    pos[i*3  ]=r*Math.sin(ph)*Math.cos(th);
    pos[i*3+1]=r*Math.cos(ph);
    pos[i*3+2]=r*Math.sin(ph)*Math.sin(th);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  return new THREE.Points(geo, new THREE.PointsMaterial({size:2,color:0xffffff}));
}
function makePlanet(radius,dist,colorHex){
  const g=new THREE.SphereGeometry(radius,32,16);
  const m=new THREE.MeshStandardMaterial({color:colorHex,roughness:0.9,metalness:0.0});
  const s=new THREE.Mesh(g,m); s.position.set(dist*0.8,dist*0.2,-dist); return s;
}

/////////////////////////
// Game State & UI DOM //
/////////////////////////
const ui={ seed:byId('uiSeed'), qual:byId('uiQual'), spd:byId('uiSpd'), range:byId('uiRange'),
  barLaser:byId('barLaser'), barMiss:byId('barMiss'), credits:byId('uiCredits'), cargo:byId('uiCargo'), cap:byId('uiCap'),
  toast:byId('toast'), err:byId('err'), shop:byId('shop'),
  lvLaserD:byId('lvLaserD'), lvLaserC:byId('lvLaserC'), lvMissD:byId('lvMissD'), lvThrust:byId('lvThrust'),
  lvTurn:byId('lvTurn'), lvMag:byId('lvMag'), costLaserD:byId('costLaserD'), costLaserC:byId('costLaserC'),
  costMissD:byId('costMissD'), costThrust:byId('costThrust'), costTurn:byId('costTurn'), costMag:byId('costMag') };
function byId(id){ return document.getElementById(id); }
function toast(msg,ms=1200){ ui.toast.textContent=msg; ui.toast.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>ui.toast.style.display='none',ms); }
function showError(e){ ui.err.style.display='block'; ui.err.textContent=(typeof e==='string')?e:(e?.message||String(e)); console.error(e); }
addEventListener('error', e=>showError(e.error||e.message));
addEventListener('unhandledrejection', e=>showError(e.reason||e));

///////////////////////
// Controls (KB only)
///////////////////////
const keys={};
addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  if(e.code==='Digit1') setQuality('high');
  if(e.code==='Digit2') setQuality('ultra');
  if(e.code==='KeyN')  newSeed();
  if(e.code==='KeyU')  toggleShop();
});
addEventListener('keyup',e=>{ keys[e.code]=false; });
function toggleShop(){ ui.shop.style.display = (ui.shop.style.display==='none'?'block':'none'); }
ui.shop.style.display='block';

//////////////////////
// Ship & Physics   //
//////////////////////
const ship={
  pos:new THREE.Vector3(), vel:new THREE.Vector3(), quat:new THREE.Quaternion(),
  thrust:36, strafe:28, lift:28,
  yawRate:rad(100), pitchRate:rad(100), rollRate:rad(180),
  dampingLin:0.06, maxSpeed:280, range:3800,
  cargo:0, cargoCap:100, credits:0,
  laser:{ canFire:true, heat:0, over:false, cooldown:30, shotHeat:18, dmg:50, rof:10, _cd:0 },
  missile:{ canFire:true, heat:0, over:false, cooldown:18, shotHeat:34, dmg:240, reload:0.7, _cd:0 }
};

// simple visual ship + hardpoints
const shipGroup=new THREE.Group(); scene.add(shipGroup);
function buildShipMesh(){
  shipGroup.clear();
  const body = new THREE.Mesh(new THREE.ConeGeometry(0.6,2.2,10), new THREE.MeshStandardMaterial({color:0x99aaff, roughness:0.4, metalness:0.2}));
  body.rotation.x=Math.PI/2; shipGroup.add(body);
  const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.36,16,12), new THREE.MeshStandardMaterial({color:0x222a44, roughness:0.9, metalness:0.0}));
  canopy.position.set(0,0.2,-0.2); shipGroup.add(canopy);
  const wingMat = new THREE.MeshStandardMaterial({color:0x335577, roughness:0.8});
  const wingL = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.08,0.5), wingMat); wingL.position.set(-1.0,0,0); shipGroup.add(wingL);
  const wingR = wingL.clone(); wingR.position.x=1.0; shipGroup.add(wingR);
}
buildShipMesh();
const HP_LOCAL = {
  laserL: new THREE.Vector3(-0.9, 0.55, -1.6),
  laserR: new THREE.Vector3( 0.9, 0.55, -1.6),
  missile: new THREE.Vector3(0, -0.05, -1.9)
};
function hardpointWorld(local){ return local.clone().applyQuaternion(ship.quat).add(ship.pos); }

//////////////////////
// Upgrades storage //
//////////////////////
const upgrades={ laserD:1, laserC:1, missD:1, thrust:1, turn:1, magnet:1, lightning:false, mass:false, grav:false };
const baseCosts={ laserD:200, laserC:150, missD:300, thrust:250, turn:200, magnet:180 };
function levelCost(base,lv){ return Math.round(base * Math.pow(1.6, lv-1)); }
function refreshShop(){
  ui.lvLaserD.textContent=upgrades.laserD; ui.lvLaserC.textContent=upgrades.laserC; ui.lvMissD.textContent=upgrades.missD;
  ui.lvThrust.textContent=upgrades.thrust; ui.lvTurn.textContent=upgrades.turn; ui.lvMag.textContent=upgrades.magnet;
  ui.costLaserD.textContent=levelCost(baseCosts.laserD, upgrades.laserD+1);
  ui.costLaserC.textContent=levelCost(baseCosts.laserC, upgrades.laserC+1);
  ui.costMissD.textContent=levelCost(baseCosts.missD, upgrades.missD+1);
  ui.costThrust.textContent=levelCost(baseCosts.thrust, upgrades.thrust+1);
  ui.costTurn.textContent=levelCost(baseCosts.turn, upgrades.turn+1);
  ui.costMag.textContent=levelCost(baseCosts.magnet, upgrades.magnet+1);
  byId('unlockLightning').textContent = upgrades.lightning?'Unlocked':'Locked (1200)';
  byId('unlockMass').textContent      = upgrades.mass?'Unlocked':'Locked (900)';
  byId('unlockGrav').textContent      = upgrades.grav?'Unlocked':'Locked (1500)';
}
function tryBuy(kind){
  const nextLv = (kind==='laserD'?upgrades.laserD: kind==='laserC'?upgrades.laserC: kind==='missD'?upgrades.missD:
                 kind==='thrust'?upgrades.thrust: kind==='turn'?upgrades.turn: upgrades.magnet) + 1;
  const cost = levelCost(baseCosts[kind], nextLv);
  if (ship.credits < cost){ toast('Not enough credits'); return; }
  ship.credits -= cost;
  if (kind==='laserD'){ upgrades.laserD++; ship.laser.dmg = 50 + (upgrades.laserD-1)*18; }
  if (kind==='laserC'){ upgrades.laserC++; ship.laser.cooldown = 30 + (upgrades.laserC-1)*6; ship.laser.shotHeat = Math.max(8, 18 - (upgrades.laserC-1)*2); }
  if (kind==='missD'){ upgrades.missD++; ship.missile.dmg = 240 + (upgrades.missD-1)*80; }
  if (kind==='thrust'){ upgrades.thrust++; ship.thrust = 36 + (upgrades.thrust-1)*6; ship.strafe = 28 + (upgrades.thrust-1)*5; ship.lift = 28 + (upgrades.thrust-1)*5; ship.maxSpeed = 280 + (upgrades.thrust-1)*20; }
  if (kind==='turn'){ upgrades.turn++; ship.yawRate=rad(100 + (upgrades.turn-1)*10); ship.pitchRate=rad(100 + (upgrades.turn-1)*10); ship.rollRate=rad(180 + (upgrades.turn-1)*18); }
  if (kind==='magnet'){ upgrades.magnet++; ship.cargoCap = 100 + (upgrades.magnet-1)*50; }
  refreshShop(); updateUI(); toast('Purchased '+kind.toUpperCase()+' Lv'+(nextLv)); save();
}
byId('buyLaserD').onclick=()=>tryBuy('laserD');
byId('buyLaserC').onclick=()=>tryBuy('laserC');
byId('buyMissD').onclick=()=>tryBuy('missD');
byId('buyThrust').onclick=()=>tryBuy('thrust');
byId('buyTurn').onclick=()=>tryBuy('turn');
byId('buyMag').onclick=()=>tryBuy('magnet');
byId('unlockLightning').onclick=()=>{ if (upgrades.lightning) return toast('Lightning already unlocked');
  if (ship.credits>=1200){ ship.credits-=1200; upgrades.lightning=true; toast('Lightning Beam unlocked (binding coming soon)'); save(); updateUI(); refreshShop(); }
  else toast('Not enough credits'); };
byId('unlockMass').onclick=()=>{ if (upgrades.mass) return toast('Mass Driver already unlocked');
  if (ship.credits>=900){ ship.credits-=900; upgrades.mass=true; toast('Mass Driver unlocked (binding coming soon)'); save(); updateUI(); refreshShop(); }
  else toast('Not enough credits'); };
byId('unlockGrav').onclick=()=>{ if (upgrades.grav) return toast('Gravity Gun already unlocked');
  if (ship.credits>=1500){ ship.credits-=1500; upgrades.grav=true; toast('Gravity Gun unlocked (binding coming soon)'); save(); updateUI(); refreshShop(); }
  else toast('Not enough credits'); };

//////////////////////////
// Asteroids & Pickups  //
//////////////////////////
let quality='high';
let seed=(Math.random()*1e9)|0;
const AST={ inst:[], data:[], count:0, geo:[], mat:null };
const DROPS={ inst:null, data:[], count:0, cap:0, geo:null, mat:null };
const MISSILES=[];   // {pos,vel,life,mesh,trailT}
const LASER_BEAMS=[];// {start,dir,len,mesh,outer,startGlow,endGlow,t,life,growTime}

function setQuality(q){ quality=q; ui.qual.textContent=q==='ultra'?'Ultra':'High'; buildWorld(seed); }
function newSeed(){ seed = (seed*1664525 + 1013904223)>>>0; buildWorld(seed); }

/////////////////////////////
// Loot / Drops generation //
/////////////////////////////
const RES_KINDS=[
  {name:'Iron', val:8,  color:0xa0a8b8},
  {name:'Nickel',val:10, color:0x9fb7aa},
  {name:'Silver',val:14, color:0xc0c0ff},
  {name:'Gold',  val:22, color:0xffd54a},
  {name:'Platinum',val:30,color:0xd9d9ff},
  {name:'Iridium', val:40,color:0xa3d1ff},
];

function lootColorForSize(sz){
  if (sz>18) return 0xffd54a; // gold
  if (sz>12) return 0xd9d9ff; // platinum
  if (sz>8)  return 0xc0c0ff; // silver
  return 0xa0a8b8;            // iron
}

// BIG guaranteed drops on asteroid destroy
function addDropsOnDestroy(asteroid){
  const baseScale = clamp(asteroid.size*0.5, 1.5, 20); // ~half the asteroid size
  const count = 2 + (asteroid.size>20?1:0);            // 2–3 big chunks
  for (let i=0;i<count;i++){
    const off = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(asteroid.size*0.25);
    const pos = new THREE.Vector3(asteroid.x,asteroid.y,asteroid.z).add(off);
    const val = Math.round(baseScale*12 + Math.random()*20);
    const color = lootColorForSize(baseScale);
    spawnDrop(pos, val, color, baseScale);
  }
}

// Chance to chip small loot on any successful laser hit
function maybeChipLoot(hitPoint){
  if (Math.random()<0.25){ // 25% per laser impact
    const scale = 0.8 + Math.random()*0.8; // small shard
    const val = Math.round(6 + scale*6);
    const color = 0xc0c0ff;
    spawnDrop(hitPoint, val, color, scale);
  }
}

function resetDrops(){
  if (DROPS.inst){ scene.remove(DROPS.inst); DROPS.inst.geometry.dispose(); DROPS.inst.material.dispose(); }
  DROPS.count=0; DROPS.data=[];
  DROPS.geo=new THREE.OctahedronGeometry(1,0);
  DROPS.mat=new THREE.MeshStandardMaterial({
    vertexColors:true, roughness:0.25, metalness:0.45,
    emissive:0x202020, emissiveIntensity:0.6
  });
  DROPS.cap=(quality==='ultra'?3500:2000);
  DROPS.inst=new THREE.InstancedMesh(DROPS.geo, DROPS.mat, DROPS.cap);
  DROPS.inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  DROPS.inst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(DROPS.cap*3),3);
  scene.add(DROPS.inst);
}

// loot glow sprite texture
function makeGlowTexture(size=96, inner=0.0, outer=1.0, col='rgba(255,240,140,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d'); const g=x.createRadialGradient(size/2,size/2,size*inner, size/2,size/2,size*outer);
  g.addColorStop(0, col); g.addColorStop(1, 'rgba(255,240,140,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  const t=new THREE.CanvasTexture(c); t.anisotropy=4; return t;
}
const glowTexLoot = makeGlowTexture(128, 0.0, 0.55, 'rgba(255,240,140,1)');

function spawnDrop(pos,value,color,scale=1.4){
  if (DROPS.count>=DROPS.cap) return;
  const id=DROPS.count++;
  const vel=new THREE.Vector3((Math.random()-0.5)*3,(Math.random()-0.5)*3,(Math.random()-0.5)*3);
  const flare=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexLoot, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.85}));
  flare.position.copy(pos); flare.scale.setScalar(Math.min(28, scale*1.6)); scene.add(flare);

  DROPS.data[id]={ pos:pos.clone(), vel, value, alive:true, color, scale, flare };
  const m=new THREE.Matrix4(), q=new THREE.Quaternion(), s=new THREE.Vector3(scale,scale,scale);
  m.compose(DROPS.data[id].pos,q,s);
  DROPS.inst.setMatrixAt(id,m);
  DROPS.inst.setColorAt(id, new THREE.Color(color));
  DROPS.inst.count=DROPS.count;
  DROPS.inst.instanceMatrix.needsUpdate=true;
  DROPS.inst.instanceColor.needsUpdate=true;
}

/////////////////////////////
// Asteroid field creation //
/////////////////////////////
function makeRockGeometry(seed,scale=1){
  const g=new THREE.IcosahedronGeometry(scale,1);
  const pos=g.attributes.position, R=rng(seed);
  for(let i=0;i<pos.count;i++){
    const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i));
    const n=v.clone().normalize();
    v.addScaledVector(n,(R()-0.5)*(0.35 + R()*0.55));
    pos.setXYZ(i,v.x,v.y,v.z);
  }
  g.computeVertexNormals(); return g;
}
function resetAsteroids(){
  AST.inst.forEach(im=>{ scene.remove(im); im.geometry.dispose(); im.material.dispose(); });
  AST.inst=[]; AST.data=[]; AST.count=0; AST.geo=[];
}
function buildAsteroids(seed){
  resetAsteroids();
  const count = (quality==='ultra') ? 1800 : 900;
  AST.geo=[ makeRockGeometry(seed^0x1111,1), makeRockGeometry(seed^0x2222,1.2), makeRockGeometry(seed^0x3333,0.9) ];
  AST.mat=new THREE.MeshStandardMaterial({color:0x88909a, roughness:0.95, metalness:0.05});
  const per=[Math.floor(count*0.4), Math.floor(count*0.35), count - Math.floor(count*0.4) - Math.floor(count*0.35)];
  const beltR = 2500, beltW=1200, beltH=800;
  const R=rng(seed^0xBEEF);
  for(let gi=0; gi<3; gi++){
    const n=per[gi];
    const inst=new THREE.InstancedMesh(AST.geo[gi], AST.mat, n);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    inst.frustumCulled=false; scene.add(inst); AST.inst.push(inst);
    for(let i=0;i<n;i++){
      const a=R()*Math.PI*2, r=beltR + (R()*2-1)*beltW;
      const x=Math.cos(a)*r, z=Math.sin(a)*r, y=(R()*2-1)*beltH;
      const size= 6 + Math.pow(R(),2)*40; // 6..46
      // Easier to destroy to make drops common
      const hp = Math.round( (size*1.1) + (gi*6) );
      const rot=new THREE.Quaternion().setFromEuler(new THREE.Euler(R()*Math.PI, R()*Math.PI, R()*Math.PI));
      const scale=new THREE.Vector3(size,size,size);
      const m=new THREE.Matrix4(); m.compose(new THREE.Vector3(x,y,z), rot, scale);
      inst.setMatrixAt(i, m);
      AST.data.push({ x,y,z, size, hp, alive:true, gi, idx:i });
      AST.count++;
    }
    inst.instanceMatrix.needsUpdate=true;
  }
}

function destroyAsteroid(rec){
  if (!rec.alive) return;
  rec.alive=false;
  const inst=AST.inst[rec.gi];
  const m=new THREE.Matrix4();
  m.compose(new THREE.Vector3(999999,999999,999999), new THREE.Quaternion(), new THREE.Vector3(0.0001,0.0001,0.0001));
  inst.setMatrixAt(rec.idx, m); inst.instanceMatrix.needsUpdate=true;

  addDropsOnDestroy(rec);
  spawnExplosion(new THREE.Vector3(rec.x,rec.y,rec.z), rec.size);
}

/////////////////////
// Visual Effects  //
/////////////////////
const FX={ group:new THREE.Group() }; scene.add(FX.group);

// beam/torp glow textures
function makeBeamGlow(size=96, inner=0.0, outer=1.0, col='rgba(130,200,255,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d'); const g=x.createRadialGradient(size/2,size/2,size*inner, size/2,size/2,size*outer);
  g.addColorStop(0, col); g.addColorStop(1, 'rgba(130,200,255,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  const t=new THREE.CanvasTexture(c); t.anisotropy=4; return t;
}
const glowTexBlue   = makeBeamGlow(128, 0.0, 0.5, 'rgba(130,200,255,1)');
const glowTexOrange = makeBeamGlow(128, 0.0, 0.5, 'rgba(255,180,80,1)');

function spawnExplosion(pos,scale){
  const g=new THREE.SphereGeometry(1, 10, 8);
  const m=new THREE.MeshBasicMaterial({color:0xffaa55, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false});
  const s=new THREE.Mesh(g,m);
  s.position.copy(pos); s.scale.setScalar(0.5);
  s.userData.t=0; s.userData.life=0.4; s.userData.scale=scale*0.08+0.6;
  FX.group.add(s);
}

///////////////////////////////
// BIG Laser Beams (twin)   //
///////////////////////////////
function createLaserBeam(start,end){
  const dir = end.clone().sub(start);
  const len = Math.max(0.001, dir.length());
  const dirN = dir.clone().normalize();

  // base geometry height=1; we scale Y to length over time
  const gCore = new THREE.CylinderGeometry(1.3, 1.3, 1, 18, 1, true);
  const mCore = new THREE.MeshBasicMaterial({color:0x88ccff, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending, depthWrite:false});
  const core  = new THREE.Mesh(gCore, mCore);

  const gGlow = new THREE.CylinderGeometry(2.6, 2.6, 1, 18, 1, true);
  const mGlow = new THREE.MeshBasicMaterial({color:0x66aaff, transparent:true, opacity:0.35, blending:THREE.AdditiveBlending, depthWrite:false});
  const glow  = new THREE.Mesh(gGlow, mGlow);

  const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirN);
  core.quaternion.copy(q); glow.quaternion.copy(q);

  // start / end flares
  const startSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.95}));
  const endSprite  =new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.95}));
  startSprite.scale.set(7,7,1); endSprite.scale.set(9,9,1);

  scene.add(core,glow,startSprite,endSprite);

  return { start:start.clone(), dir:dirN, len, mesh:core, outer:glow, startGlow:startSprite, endGlow:endSprite, t:0, life:0.22, growTime:0.06 };
}
function updateBeam(b,dt){
  b.t+=dt;
  const p = Math.min(1, b.t / b.growTime);
  const L = b.len * p;
  const mid = b.start.clone().addScaledVector(b.dir, L*0.5);
  b.mesh.position.copy(mid); b.outer.position.copy(mid);
  b.mesh.scale.set(1, L, 1); b.outer.scale.set(1, L, 1);
  b.startGlow.position.copy(b.start);
  b.endGlow.position.copy(b.start.clone().addScaledVector(b.dir, L));
  const f = (b.t<=b.growTime) ? 1 : Math.max(0, 1 - (b.t - b.growTime)/(b.life - b.growTime));
  b.mesh.material.opacity = 0.95*f; b.outer.material.opacity = 0.35*f;
  b.startGlow.material.opacity = 0.95*f; b.endGlow.material.opacity = 0.95*f;
}
function removeBeam(b){
  scene.remove(b.mesh,b.outer,b.startGlow,b.endGlow);
  b.mesh.geometry.dispose(); b.mesh.material.dispose();
  b.outer.geometry.dispose(); b.outer.material.dispose();
  b.startGlow.material.map.dispose(); b.startGlow.material.dispose();
  b.endGlow.material.map.dispose(); b.endGlow.material.dispose();
}

/////////////////////////////
// Photon Torpedo Missiles //
/////////////////////////////
function spawnMissile(reticleDir){
  const nose = hardpointWorld(HP_LOCAL.missile);
  const core=new THREE.Mesh(new THREE.SphereGeometry(0.7, 14, 12),
    new THREE.MeshBasicMaterial({color:0xffcc88, transparent:true, opacity:1, blending:THREE.AdditiveBlending, depthWrite:false}));
  const glow=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.9}));
  glow.scale.set(7,7,1);
  const group=new THREE.Group(); group.add(glow,core); group.position.copy(nose); scene.add(group);
  const m={ pos:nose.clone(), vel:reticleDir.clone().multiplyScalar(180), life:10, mesh:group, trailT:0 };
  MISSILES.push(m);
}

/////////////////////////////////////////////
// Reticle Ray → find target along center  //
/////////////////////////////////////////////
function getReticleRay(){
  const origin = camera.position.clone();
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  return { origin, dir };
}
function rayHitAsteroids(origin, dir, maxRange){
  let bestT=Infinity, best=null;
  for (let i=0;i<AST.data.length;i++){
    const a=AST.data[i]; if(!a.alive) continue;
    const C=new THREE.Vector3(a.x,a.y,a.z), r=a.size;
    const L=C.clone().sub(origin);
    const tca = L.dot(dir); if (tca<0) continue;
    const d2 = L.lengthSq() - tca*tca; if (d2 > r*r) continue;
    const thc = Math.sqrt(Math.max(0, r*r - d2));
    const t0 = tca - thc; if (t0>0 && t0<bestT){ bestT=t0; best=a; }
  }
  if (best && bestT<=maxRange) return { hit:true, t:bestT, rock:best, point: origin.clone().addScaledVector(dir, bestT) };
  return { hit:false, t:maxRange, rock:null, point: origin.clone().addScaledVector(dir, maxRange) };
}

/////////////////////////
// Weapons & Firing    //
/////////////////////////
function fireLaser(){
  const L=ship.laser; if (L.over || L._cd>0) return;
  L.heat += L.shotHeat; if (L.heat>=100){ L.over=true; toast('Laser overheated!'); }
  L._cd = 1/Math.max(3, ship.laser.rof);

  const {origin,dir} = getReticleRay();
  const pick = rayHitAsteroids(origin, dir, ship.range);
  const endPoint = pick.point.clone();

  const startL = hardpointWorld(HP_LOCAL.laserL);
  const startR = hardpointWorld(HP_LOCAL.laserR);
  LASER_BEAMS.push( createLaserBeam(startL, endPoint) );
  LASER_BEAMS.push( createLaserBeam(startR, endPoint) );

  if (pick.hit){
    pick.rock.hp -= ship.laser.dmg;
    maybeChipLoot(endPoint);
    if (pick.rock.hp<=0) destroyAsteroid(pick.rock);
  }
}
function fireMissile(){
  const M=ship.missile; if (M.over || M._cd>0) return;
  M.heat += M.shotHeat; if (M.heat>=100){ M.over=true; toast('Missiles overheated!'); }
  M._cd = M.reload;
  const {dir} = getReticleRay();
  spawnMissile(dir);
}

//////////////////////
// Build the World  //
//////////////////////
let stars, planetA, planetB;
function buildWorld(s){
  // clear all transient visuals
  for(const b of LASER_BEAMS){ removeBeam(b); } LASER_BEAMS.length=0;
  for (let i=MISSILES.length-1;i>=0;i--){ scene.remove(MISSILES[i].mesh); } MISSILES.length=0;
  for (let i=FX.group.children.length-1;i>=0;i--){ const n=FX.group.children[i]; FX.group.remove(n); n.geometry?.dispose?.(); n.material?.dispose?.(); }

  resetDrops(); buildAsteroids(s);

  if (stars) scene.remove(stars); stars=makeStarfield(s^0x1234, 6000, 60000); scene.add(stars);
  if (planetA) scene.remove(planetA); if (planetB) scene.remove(planetB);
  planetA=makePlanet(4200, 70000, 0x1f2a7a); scene.add(planetA);
  planetB=makePlanet(2600,110000, 0x7a3f1f); scene.add(planetB);

  // ship reset
  ship.pos.set(0,0,0); ship.vel.set(0,0,0); ship.quat.identity();
  ship.laser.heat=0; ship.laser.over=false; ship.laser._cd=0;
  ship.missile.heat=0; ship.missile.over=false; ship.missile._cd=0;
  ui.seed.textContent=s; ui.cap.textContent=ship.cargoCap;
  updateUI();
}

//////////////////////
// Persistence (LS) //
//////////////////////
const LSKEY='astrominer_save_v1';
function save(){ const data={seed,quality,credits:ship.credits,cargo:ship.cargo,upgrades}; localStorage.setItem(LSKEY, JSON.stringify(data)); }
function load(){
  try{
    const j=localStorage.getItem(LSKEY); if(!j) return;
    const d=JSON.parse(j);
    if (d.seed) seed=d.seed; if (d.quality) quality=d.quality;
    if (d.credits!=null) ship.credits=d.credits; if (d.cargo!=null) ship.cargo=d.cargo;
    if (d.upgrades) Object.assign(upgrades,d.upgrades);
    ship.laser.dmg = 50 + (upgrades.laserD-1)*18;
    ship.laser.cooldown = 30 + (upgrades.laserC-1)*6;
    ship.laser.shotHeat = Math.max(8, 18 - (upgrades.laserC-1)*2);
    ship.missile.dmg = 240 + (upgrades.missD-1)*80;
    ship.thrust = 36 + (upgrades.thrust-1)*6;
    ship.strafe = 28 + (upgrades.thrust-1)*5;
    ship.lift   = 28 + (upgrades.thrust-1)*5;
    ship.maxSpeed = 280 + (upgrades.thrust-1)*20;
    ship.yawRate=rad(100 + (upgrades.turn-1)*10);
    ship.pitchRate=rad(100 + (upgrades.turn-1)*10);
    ship.rollRate=rad(180 + (upgrades.turn-1)*18);
    ship.cargoCap = 100 + (upgrades.magnet-1)*50;
  }catch(e){ console.warn('save load failed',e); }
}

//////////////////////
// UI Refresh       //
//////////////////////
function updateUI(){
  ui.spd.textContent=ship.vel.length().toFixed(1);
  ui.range.textContent=ship.range.toFixed(0);
  ui.credits.textContent=ship.credits|0;
  ui.cargo.textContent=ship.cargo|0;
  ui.barLaser.style.width = clamp(ship.laser.heat,0,100)+'%';
  ui.barMiss.style.width  = clamp(ship.missile.heat,0,100)+'%';
  refreshShop();
}

//////////////////////
// Game Loop        //
//////////////////////
const clock=new THREE.Clock();
function handleInput(dt){
  // rotation
  const yaw   = ((keys['KeyA']?1:0) - (keys['KeyD']?1:0)) * ship.yawRate   * dt;
  // SWAPPED for direct up/down: W = pitch up, S = pitch down
  const pitch = ((keys['KeyW']?1:0) - (keys['KeyS']?1:0)) * ship.pitchRate * dt;
  const roll  = ((keys['KeyQ']?1:0) - (keys['KeyE']?1:0)) * ship.rollRate  * dt;
  const qYaw   = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),  yaw);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),  pitch);
  const qRoll  = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -roll);
  ship.quat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  // local axes
  const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat);
  const up =new THREE.Vector3(0,1,0).applyQuaternion(ship.quat);
  const right=new THREE.Vector3(1,0,0).applyQuaternion(ship.quat);

  // translation thrusters
  const thrustF = (keys['ArrowUp']?1:0) - (keys['ArrowDown']?1:0);
  const thrustX = (keys['ArrowRight']?1:0) - (keys['ArrowLeft']?1:0);
  const thrustY = (keys['KeyR']?1:0) - (keys['KeyF']?1:0);
  ship.vel.addScaledVector(fwd,   thrustF * ship.thrust * dt);
  ship.vel.addScaledVector(right, thrustX * ship.strafe * dt);
  ship.vel.addScaledVector(up,    thrustY * ship.lift   * dt);

  // dampers
  if (keys['KeyZ']) ship.vel.multiplyScalar(Math.pow(1-0.9, dt*60));
  else ship.vel.multiplyScalar(1 - ship.dampingLin*dt);

  const spd=ship.vel.length(); if (spd>ship.maxSpeed) ship.vel.multiplyScalar(ship.maxSpeed/spd);

  // weapons
  if (keys['Space']) fireLaser();
  if (keys['KeyX'])  fireMissile();
}

function updateMissiles(dt){
  for (let i=MISSILES.length-1;i>=0;i--){
    const m=MISSILES[i];

    // light homing toward reticle ray hit
    const {origin,dir} = getReticleRay();
    const pick = rayHitAsteroids(origin, dir, 1600);
    if (pick.hit){
      const aim=pick.point.clone().sub(m.pos).normalize();
      m.vel.lerp(aim.multiplyScalar(200), 0.02);
    }

    m.pos.addScaledVector(m.vel, dt);
    m.mesh.position.copy(m.pos);
    m.life -= dt;

    // trail
    m.trailT = (m.trailT||0)+dt;
    if (m.trailT>0.03){
      m.trailT=0;
      const s=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.8}));
      s.position.copy(m.pos); s.scale.set(5,5,1);
      s.userData.t=0; s.userData.life=0.35; FX.group.add(s);
    }

    // collision
    let hit=null;
    for (let j=0;j<AST.data.length;j++){
      const a=AST.data[j]; if(!a.alive) continue;
      const dx=m.pos.x-a.x, dy=m.pos.y-a.y, dz=m.pos.z-a.z;
      const r=a.size*1.15;
      if (dx*dx+dy*dy+dz*dz <= r*r){ hit=a; break; }
    }
    if (hit){
      hit.hp -= ship.missile.dmg;
      if (hit.hp<=0) destroyAsteroid(hit);
      spawnExplosion(m.pos, 2.4);
      scene.remove(m.mesh); MISSILES.splice(i,1);
    } else if (m.life<=0){ scene.remove(m.mesh); MISSILES.splice(i,1); }
  }
}

function updateDrops(dt){
  // stronger magnet + auto-homing, ranges scale with drop size
  const magnetBase = 14 + (upgrades.magnet-1)*8;
  for (let i=0;i<DROPS.count;i++){
    const d=DROPS.data[i]; if (!d || !d.alive) continue;
    d.pos.addScaledVector(d.vel, dt);
    d.vel.multiplyScalar(0.992);

    // update glow sprite
    if (d.flare){ d.flare.position.copy(d.pos); d.flare.scale.setScalar(Math.min(28, d.scale*1.6)); }

    const toShip= ship.pos.clone().sub(d.pos);
    const dist=toShip.length();
    const range = magnetBase + d.scale*2.0;     // larger items pull from further away
    if (dist < range){
      const accel = (magnetBase*1.2) + d.scale*0.8; // bigger items accelerate harder toward you
      d.vel.add(toShip.normalize().multiplyScalar(accel*dt));
    }

    // pickup radius scales with size
    const pickupR = 6 + d.scale*0.4;
    if (dist < pickupR){
      d.alive=false;
      ship.credits += d.value;
      ship.cargo = Math.min(ship.cargoCap, ship.cargo + 1);
      toast('+'+d.value+' cr');
      // hide instance
      const mtx=new THREE.Matrix4();
      mtx.compose(new THREE.Vector3(999999,999999,999999), new THREE.Quaternion(), new THREE.Vector3(0.0001,0.0001,0.0001));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true;
      if (d.flare){ scene.remove(d.flare); d.flare.material.map.dispose(); d.flare.material.dispose(); }
      updateUI(); save();
    } else {
      const mtx=new THREE.Matrix4();
      mtx.compose(d.pos, new THREE.Quaternion(), new THREE.Vector3(d.scale,d.scale,d.scale));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true;
    }
  }
}

function updateFX(dt){
  // fade sprites/explosions
  for (let i=FX.group.children.length-1;i>=0;i--){
    const s=FX.group.children[i]; s.userData.t=(s.userData.t||0)+dt; const t=s.userData.t/(s.userData.life||0.35);
    if (s.isSprite){ s.material.opacity = 0.8*(1-t); s.scale.setScalar(THREE.MathUtils.lerp(5, 2.2, t)); }
    else { s.scale.setScalar(THREE.MathUtils.lerp(0.5, s.userData.scale||1, t)); s.material.opacity = 0.9*(1-t); }
    if (t>=1){ FX.group.remove(s); s.material.map?.dispose?.(); s.material.dispose(); s.geometry?.dispose?.(); }
  }

  // update laser beams
  for (let i=LASER_BEAMS.length-1;i>=0;i--){
    const b=LASER_BEAMS[i]; updateBeam(b,dt);
    if (b.t>=b.life){ removeBeam(b); LASER_BEAMS.splice(i,1); }
  }
}

function loop(){
  const dt=Math.min(0.033, clock.getDelta());
  handleInput(dt);
  ship.pos.addScaledVector(ship.vel, dt);

  // ship visual follow
  shipGroup.position.copy(ship.pos); shipGroup.quaternion.copy(ship.quat);

  // cooldowns / heat
  ship.laser._cd=Math.max(0, ship.laser._cd - dt);
  ship.laser.heat=Math.max(0, ship.laser.heat - ship.laser.cooldown*dt);
  if (ship.laser.over && ship.laser.heat<=35){ ship.laser.over=false; toast('Laser ready'); }
  ship.missile._cd=Math.max(0, ship.missile._cd - dt);
  ship.missile.heat=Math.max(0, ship.missile.heat - ship.missile.cooldown*dt);
  if (ship.missile.over && ship.missile.heat<=35){ ship.missile.over=false; toast('Missiles ready'); }

  updateMissiles(dt);
  updateDrops(dt);
  updateFX(dt);

  // camera follow
  const camOffset=new THREE.Vector3(0,1.0,4.6).applyQuaternion(ship.quat);
  const targetPos = ship.pos.clone().sub(camOffset);
  camera.position.lerp(targetPos, 0.18);
  const look=ship.pos.clone().add(new THREE.Vector3(0,0,-12).applyQuaternion(ship.quat));
  camera.quaternion.slerp(new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(camera.position, look, new THREE.Vector3(0,1,0))), 0.2);

  // sun parallax
  sun.position.copy(ship.pos).add(new THREE.Vector3(1,0.2,0.3).multiplyScalar(30000));

  updateUI();
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}

//////////////
// Boot     //
//////////////
function onResize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize', onResize);
function init(){
  load(); ui.qual.textContent=(quality==='ultra')?'Ultra':'High'; ui.seed.textContent=seed; refreshShop();
  scene.background = new THREE.Color(0x000000);
  buildWorld(seed);
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>

