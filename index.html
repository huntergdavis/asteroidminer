<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AstroMiner — Target Ring • Varied Asteroids • New Upgrades</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --ret: rgba(173,216,255,.9);
    --retGlow: rgba(120,180,255,.55);
    --retGlow2: rgba(120,180,255,.35);
    --retScale: 1;
  }
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#eef}
  #app{position:fixed;inset:0;overflow:hidden}

  .hud{position:absolute;left:10px;top:10px;background:rgba(0,0,0,.45);padding:10px 12px;border-radius:12px;font-size:12px;backdrop-filter:blur(2px);line-height:1.25;z-index:5}
  .shop{position:absolute;right:10px;top:10px;background:rgba(0,0,0,.55);padding:10px 12px;border-radius:12px;min-width:260px;max-width:380px;font-size:12px;z-index:5}
  .shop h3{margin:0 0 6px;font-size:13px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0}
  .row button{background:#1f3b8f;border:0;color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}
  .row button[disabled]{opacity:.45;cursor:not-allowed}
  .k{opacity:.8}
  .bar{height:8px;background:#223;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(#66e,#44a);width:0}
  .bar.red>span{background:linear-gradient(#f66,#b22)}
  .bar>span.warn{animation:blink .35s linear infinite alternate}
  @keyframes blink{from{filter:brightness(1)}to{filter:brightness(2.1)}}
  .cash{font-weight:700}
  .help{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:12px;max-width:740px;z-index:5}
  .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:10px;font-size:12px;display:none;z-index:6}
  .err{position:absolute;right:10px;bottom:10px;background:#300;color:#fee;padding:8px 10px;border-radius:10px;max-width:60ch;display:none;white-space:pre-wrap;z-index:6}

  .ret{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(var(--retScale));pointer-events:none;opacity:.9;z-index:4}
  .ret .ring{width:46px;height:46px;border:2px solid var(--ret);border-radius:50%;box-shadow:0 0 18px var(--retGlow) inset,0 0 22px var(--retGlow2)}
  .ret .lines{position:absolute;left:0;top:0;width:46px;height:46px}
  .ret .lines::before,.ret .lines::after{content:"";position:absolute;background:var(--ret)}
  .ret .lines::before{left:50%;top:-10px;transform:translateX(-50%);width:2px;height:12px;box-shadow:0 44px 0 0 var(--ret)}
  .ret .lines::after{top:50%;left:-10px;transform:translateY(-50%);height:2px;width:12px;box-shadow:44px 0 0 0 var(--ret)}

  .flash{position:fixed;inset:0;pointer-events:none;opacity:0;mix-blend-mode:screen;background:
    radial-gradient(ellipse at center, rgba(255,255,255,.14), rgba(0,0,0,0) 60%);z-index:3}

  .fps{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,.55);padding:8px 10px;border-radius:10px;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:none;z-index:6}

  .tgtHud{position:absolute;left:50%;top:50%;transform:translate(-50%,calc(-50% + 42px));font-size:12px;opacity:.9;background:rgba(0,0,0,.35);padding:4px 6px;border-radius:6px;z-index:5;pointer-events:none;display:none}

  /* Loading overlay */
  .loading{position:fixed;inset:0;background:radial-gradient(ellipse at center,#0a0f1a 10%,#000 70%);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:#cfe6ff;z-index:10}
  .spinner{width:44px;height:44px;border-radius:50%;border:4px solid rgba(120,180,255,.25);border-top-color:#7fb2ff;animation:spin 0.9s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .loadbar{width:min(420px,80vw);height:8px;background:#12223a;border-radius:10px;overflow:hidden;box-shadow:0 0 0 1px #1b2a46 inset}
  .loadbar>span{display:block;height:100%;width:0;background:linear-gradient(90deg,#66aaff,#44e);border-radius:10px}
  .loading small{opacity:.8}
</style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Seed:</b> <span id="uiSeed">0</span> · <b>Quality:</b> <span id="uiQual">High</span></div>
  <div style="margin-top:6px"><b>Speed:</b> <span id="uiSpd">0</span> m/s · <b>Range:</b> <span id="uiRange">0</span> m</div>
  <div style="margin-top:6px"><b>Laser Heat</b><div class="bar"><span id="barLaser"></span></div></div>
  <div style="margin-top:6px"><b>Missile Heat</b><div class="bar red"><span id="barMiss"></span></div></div>
  <div style="margin-top:6px"><b>Cargo</b>: <span id="uiCargo">0</span> / <span id="uiCap">100</span></div>
  <div><b>Credits</b>: <span class="cash" id="uiCredits">0</span></div>
  <div style="margin-top:6px"><b>Refinery</b>: <span id="uiRef">—</span> m (Dock: <b>C</b>)</div>
</div>

<div class="shop" id="shop">
  <h3>Ship Upgrades</h3>
  <div class="row"><span>Laser Damage Lv <b id="lvLaserD">1</b></span><button id="buyLaserD">Buy (<span id="costLaserD">200</span>)</button></div>
  <div class="row"><span>Laser Cooling Lv <b id="lvLaserC">1</b></span><button id="buyLaserC">Buy (<span id="costLaserC">150</span>)</button></div>
  <div class="row"><span>Missile Damage Lv <b id="lvMissD">1</b></span><button id="buyMissD">Buy (<span id="costMissD">300</span>)</button></div>
  <div class="row"><span>Engine Thrust Lv <b id="lvThrust">1</b></span><button id="buyThrust">Buy (<span id="costThrust">250</span>)</button></div>
  <div class="row"><span>Turn Rate Lv <b id="lvTurn">1</b></span><button id="buyTurn">Buy (<span id="costTurn">200</span>)</button></div>
  <div class="row"><span>Cargo Magnet Lv <b id="lvMag">1</b></span><button id="buyMag">Buy (<span id="costMag">180</span>)</button></div>
  <hr style="border-color:#234">
  <div class="row"><span>Range Extender Lv <b id="lvRange">1</b></span><button id="buyRange">Buy (<span id="costRange">260</span>)</button></div>
  <div class="row"><span>Cargo Hold Lv <b id="lvHold">1</b></span><button id="buyHold">Buy (<span id="costHold">220</span>)</button></div>
  <div class="row"><span>Refinery Yield Lv <b id="lvYield">1</b></span><button id="buyYield">Buy (<span id="costYield">300</span>)</button></div>
  <hr style="border-color:#234">
  <div class="row"><span class="k">Lightning Beam</span><button id="unlockLightning">Locked (1200)</button></div>
  <div class="row"><span class="k">Mass Driver</span><button id="unlockMass">Locked (900)</button></div>
  <div class="row"><span class="k">Gravity Gun</span><button id="unlockGrav">Locked (1500)</button></div>
  <div style="margin-top:6px;opacity:.75">
    Toggle shop: <b>U</b> · Quality: <b>1</b>=High, <b>2</b>=Ultra · New Seed: <b>N</b> · Auto‑Level: <b>L</b> · FPS: <b>Shift+F</b>
  </div>
</div>

<div class="help">
  <div><b>Controls</b> — Zero-G 6-DOF</div>
  <div>Pitch: <b>W/S</b> · Yaw: <b>A/D</b> · Roll: <b>Q/E</b></div>
  <div>Forward/Reverse: <b>↑/↓</b> · Strafe: <b>←/→</b> · Lift: <b>R/F</b></div>
  <div>Brake/Damp: <b>Z</b> · Laser: <b>Space</b> · Missile: <b>X</b> · Dock: <b>C</b> · Auto‑Level: <b>L</b> · FPS: <b>Shift+F</b></div>
</div>

<!-- Reticle -->
<div class="ret"><div class="ring"></div><div class="lines"></div></div>
<div class="tgtHud" id="tgtHud">—</div>

<div class="flash" id="flash"></div>
<div class="fps" id="fps">—</div>
<div class="toast" id="toast"></div>
<div class="err" id="err"></div>

<!-- Loading overlay -->
<div class="loading" id="loading">
  <div class="spinner"></div>
  <div id="loadText">Generating sector…</div>
  <div class="loadbar"><span id="loadBar"></span></div>
  <small id="loadSub">Preparing…</small>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- Utils ---------- */
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const rad=THREE.MathUtils.degToRad;
const lerp=THREE.MathUtils.lerp;
const nextFrame=()=>new Promise(r=>requestAnimationFrame(r));
function rng(seed){ let s=seed>>>0; return ()=>{ s+=0x6D2B79F5; let t=Math.imul(s^(s>>>15),1|s); t^=t+Math.imul(t^(t>>>7),61|t); return ((t^(t>>>14))>>>0)/4294967296; }; }

/* ---------- Scene ---------- */
const app=document.getElementById('app');
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,1,240000); // near=1, with log depth improves precision
camera.position.set(0,0,0);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:false,logarithmicDepthBuffer:true,powerPreference:'high-performance'});
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setSize(innerWidth,innerHeight);
app.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x222233,0.95));
const sun=new THREE.DirectionalLight(0xffffff,0.8); sun.position.set(1,0.2,0.3).multiplyScalar(30000); scene.add(sun);

/* ---------- Glow texture helper ---------- */
function finalizeGlowTexture(t){
  t.anisotropy = 2; t.generateMipmaps = false;
  t.minFilter = THREE.LinearFilter; t.magFilter = THREE.LinearFilter;
  t.wrapS = THREE.ClampToEdgeWrapping; t.wrapT = THREE.ClampToEdgeWrapping;
  t.premultiplyAlpha = true; t.colorSpace = THREE.SRGBColorSpace; t.needsUpdate = true; return t;
}
function makeGlowTexture(size=96, inner=0.0, outer=1.0, col='rgba(255,240,140,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d'); x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer);
  g.addColorStop(0,col); g.addColorStop(1,'rgba(0,0,0,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}

/* ---------- Stars ---------- */
async function makeStarfieldAsync(seed, count, spread=90000, progress){
  const group=new THREE.Group(); const R=rng(seed);
  async function layer(n, spr, size, label){
    const geo=new THREE.BufferGeometry(); const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const r=spr*Math.pow(R(),0.22), th=R()*Math.PI*2, u=R()*2-1, ph=Math.acos(u), s=Math.sin(ph);
      pos[i*3]=r*s*Math.cos(th); pos[i*3+1]=r*Math.cos(ph); pos[i*3+2]=r*s*Math.sin(th);
      if((i&1023)===0){ progress && progress(`${label} ${Math.floor(i/n*100)}%`); await nextFrame(); }
    }
    const mat=new THREE.PointsMaterial({size, color:0xffffff, sizeAttenuation:true, transparent:false, depthWrite:false});
    const pts=new THREE.Points(geo.setAttribute('position',new THREE.BufferAttribute(pos,3)),mat);
    pts.frustumCulled=false; group.add(pts);
  }
  await layer(Math.floor(count*0.6), spread*0.9, 2.0, 'Stars A');
  await layer(Math.floor(count*0.7), spread*1.8, 1.3, 'Stars B');
  await layer(Math.floor(count*0.7), spread*2.6, 1.0, 'Stars C');
  group.frustumCulled=false; return group;
}

/* ---------- Procedural Skydome ---------- */
let skydome=null;
function makeSkydome(seed){
  const R=rng(seed);
  const c0=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c1=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c2=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const mat=new THREE.ShaderMaterial({
    side:THREE.BackSide, depthTest:false, depthWrite:false, transparent:false,
    uniforms:{
      uC0:{value:c0}, uC1:{value:c1}, uC2:{value:c2},
      uCol0:{value:new THREE.Color(0.40,0.30,0.70)},
      uCol1:{value:new THREE.Color(0.70,0.40,0.20)},
      uCol2:{value:new THREE.Color(0.20,0.50,0.80)},
      uBase:{value:new THREE.Color(0.004,0.006,0.010)}
    },
    vertexShader:`varying vec3 vDir;void main(){vec4 wp=modelMatrix*vec4(position,1.0);vDir=normalize(wp.xyz-cameraPosition);gl_Position=projectionMatrix*viewMatrix*wp;}`,
    fragmentShader:`precision mediump float;varying vec3 vDir;uniform vec3 uC0,uC1,uC2,uCol0,uCol1,uCol2,uBase;
      float lobe(vec3 d,vec3 c,float s){float m=max(0.,dot(normalize(d),normalize(c)));return pow(m,s);}
      void main(){vec3 d=normalize(vDir);float a=lobe(d,uC0,2.0),b=lobe(d,uC1,2.0),c=lobe(d,uC2,2.0);
      vec3 col=uBase+0.5*(a*uCol0+b*uCol1+c*uCol2);gl_FragColor=vec4(col,1.0);} `
  });
  const g=new THREE.SphereGeometry(220000, 32, 16);
  const dome=new THREE.Mesh(g,mat); dome.renderOrder=-100; dome.frustumCulled=false; return dome;
}

/* ---------- DOM/UI ---------- */
const byId = id=>document.getElementById(id);
const ui={
  seed:byId('uiSeed'), qual:byId('uiQual'),
  spd:byId('uiSpd'), range:byId('uiRange'),
  barLaser:byId('barLaser'), barMiss:byId('barMiss'),
  credits:byId('uiCredits'), cargo:byId('uiCargo'), cap:byId('uiCap'),
  toast:byId('toast'), err:byId('err'), shop:byId('shop'),
  lvLaserD:byId('lvLaserD'), lvLaserC:byId('lvLaserC'), lvMissD:byId('lvMissD'),
  lvThrust:byId('lvThrust'), lvTurn:byId('lvTurn'), lvMag:byId('lvMag'),
  costLaserD:byId('costLaserD'), costLaserC:byId('costLaserC'), costMissD:byId('costMissD'),
  costThrust:byId('costThrust'), costTurn:byId('costTurn'), costMag:byId('costMag'),
  lvRange:byId('lvRange'), lvHold:byId('lvHold'), lvYield:byId('lvYield'),
  costRange:byId('costRange'), costHold:byId('costHold'), costYield:byId('costYield'),
  ref:byId('uiRef'),
  flash:byId('flash'),
  fps:byId('fps'),
  tgtHud:byId('tgtHud'),
  loading:byId('loading'), loadText:byId('loadText'), loadSub:byId('loadSub'), loadBar:byId('loadBar'),
  buttons:{
    buyLaserD:byId('buyLaserD'), buyLaserC:byId('buyLaserC'), buyMissD:byId('buyMissD'),
    buyThrust:byId('buyThrust'), buyTurn:byId('buyTurn'), buyMag:byId('buyMag'),
    buyRange:byId('buyRange'), buyHold:byId('buyHold'), buyYield:byId('buyYield'),
    unlockLightning:byId('unlockLightning'), unlockMass:byId('unlockMass'), unlockGrav:byId('unlockGrav')
  }
};
function toast(msg,ms=1200){ ui.toast.textContent=msg; ui.toast.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>ui.toast.style.display='none',ms); }
function showError(e){ ui.err.style.display='block'; ui.err.textContent=(typeof e==='string')?e:(e?.message||String(e)); console.error(e); }
addEventListener('error', e=>showError(e.error||e.message));
addEventListener('unhandledrejection', e=>showError(e.reason||e));

/* ---------- Loading overlay ---------- */
const Loader={
  show(msg='Loading…'){ ui.loading.style.display='flex'; ui.loadText.textContent=msg; ui.loadSub.textContent='Preparing…'; ui.loadBar.style.width='0%'; },
  sub(msg){ ui.loadSub.textContent=msg; },
  pct(p){ ui.loadBar.style.width=(Math.floor(p*100))+'%'; },
  hide(){ ui.loading.style.display='none'; }
};

/* ---------- Input ---------- */
const keys={};
let fpsOn=false;
function toggleFPS(){ fpsOn=!fpsOn; ui.fps.style.display=fpsOn?'block':'none'; }
addEventListener('keydown',e=>{
  if(e.code==='KeyF' && e.shiftKey){ toggleFPS(); e.preventDefault(); return; }

  keys[e.code]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  if(e.code==='Digit1') setQuality('high');
  if(e.code==='Digit2') setQuality('ultra');
  if(e.code==='KeyN')  newSeed();
  if(e.code==='KeyU')  toggleShop();
  if(e.code==='KeyL')  autoLevel=!autoLevel, toast('Auto-Level: '+(autoLevel?'ON':'OFF'));

  if(AUD._ctx && AUD._ctx.state==='suspended') AUD._ctx.resume();
  if(!AUD._ctx) AUD.init();
});
addEventListener('keyup',e=>{ keys[e.code]=false; });
function toggleShop(){ ui.shop.style.display = (ui.shop.style.display==='none'?'block':'none'); }
ui.shop.style.display='block';

/* ---------- Audio (simple osc beeps) ---------- */
const AUD={
  _ctx:null,
  init(){ try{ const C=window.AudioContext||window.webkitAudioContext; this._ctx=new C(); }catch(e){} },
  beep(freq=880,dur=0.05,type='sine',gain=0.03){
    if(!this._ctx) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type=type; o.frequency.setValueAtTime(freq,t);
    g.gain.setValueAtTime(gain,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+dur);
  },
  zap(){ this.beep(880,0.05,'sawtooth',0.05); this.beep(1760,0.05,'triangle',0.03); },
  pickup(){ this.beep(1200,0.06,'sine',0.045); setTimeout(()=>this.beep(1600,0.05,'sine',0.035),40); },
  boom(){
    if(!this._ctx) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type='square'; o.frequency.setValueAtTime(80,t); o.frequency.exponentialRampToValueAtTime(30,t+0.3);
    g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.35);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+0.35);
  }
};

/* ---------- Ship ---------- */
const ship={
  pos:new THREE.Vector3(), vel:new THREE.Vector3(), quat:new THREE.Quaternion(),
  thrust:48, strafe:36, lift:36,
  yawRate:rad(100), pitchRate:rad(100), rollRate:rad(180),
  dampingLin:0.08, maxSpeed:300, range:3800,
  cargo:0, cargoCap:100, credits:0,
  laser:{ canFire:true, heat:0, over:false, cooldown:30, shotHeat:18, dmg:50, rof:10, _cd:0 },
  missile:{ canFire:true, heat:0, over:false, cooldown:18, shotHeat:34, dmg:240, reload:0.7, _cd:0 }
};
let autoLevel=false;
let baseFov=75, fovKick=0, flashAmt=0, shakeT=0, shakeAmp=0;

const shipGroup=new THREE.Group(); scene.add(shipGroup); shipGroup.visible=false;
const HP_LOCAL = { laserL:new THREE.Vector3(-0.9,0.55,-1.6), laserR:new THREE.Vector3(0.9,0.55,-1.6), missile:new THREE.Vector3(0,-0.05,-1.9) };
const eyeLocal = new THREE.Vector3(0,0.18,0);
function hardpointWorld(local){ return local.clone().applyQuaternion(ship.quat).add(ship.pos); }

/* ---------- Upgrades & Shop ---------- */
const upgrades={
  laserD:1, laserC:1, missD:1, thrust:1, turn:1, magnet:1,
  range:1, hold:1, yield:1,
  lightning:false, mass:false, grav:false
};
const baseCosts={ laserD:200, laserC:150, missD:300, thrust:250, turn:200, magnet:180, range:260, hold:220, yield:300 };
const MAX={ laserD:8, laserC:8, missD:8, thrust:8, turn:8, magnet:8, range:8, hold:8, yield:6 };
const unlockPrices={ lightning:1200, mass:900, grav:1500 };

function levelCost(base,lv){ return Math.round(base * Math.pow(1.6, lv-1)); }

function applyUpgrades(){
  ship.laser.dmg=50+(upgrades.laserD-1)*18;
  ship.laser.cooldown=30+(upgrades.laserC-1)*6;
  ship.laser.shotHeat=Math.max(8,18-(upgrades.laserC-1)*2);
  ship.missile.dmg=240+(upgrades.missD-1)*80;

  ship.thrust = 48 + (upgrades.thrust-1)*7;
  ship.strafe = 36 + (upgrades.thrust-1)*6;
  ship.lift   = 36 + (upgrades.thrust-1)*6;
  ship.maxSpeed = 300 + (upgrades.thrust-1)*24;

  ship.yawRate  = rad(100+(upgrades.turn-1)*10);
  ship.pitchRate= rad(100+(upgrades.turn-1)*10);
  ship.rollRate = rad(180+(upgrades.turn-1)*18);

  ship.cargoCap = 100 + (upgrades.hold-1)*80 + (upgrades.magnet-1)*0; // magnet stays magnet-only
  ship.range = 3800 + (upgrades.range-1)*420;
}

function refreshShop(){
  ui.lvLaserD.textContent=upgrades.laserD; ui.lvLaserC.textContent=upgrades.laserC; ui.lvMissD.textContent=upgrades.missD;
  ui.lvThrust.textContent=upgrades.thrust; ui.lvTurn.textContent=upgrades.turn; ui.lvMag.textContent=upgrades.magnet;
  ui.lvRange.textContent=upgrades.range; ui.lvHold.textContent=upgrades.hold; ui.lvYield.textContent=upgrades.yield;

  const c={};
  c.laserD=levelCost(baseCosts.laserD, upgrades.laserD+1);
  c.laserC=levelCost(baseCosts.laserC, upgrades.laserC+1);
  c.missD =levelCost(baseCosts.missD , upgrades.missD +1);
  c.thrust=levelCost(baseCosts.thrust, upgrades.thrust+1);
  c.turn  =levelCost(baseCosts.turn  , upgrades.turn  +1);
  c.magnet=levelCost(baseCosts.magnet, upgrades.magnet+1);
  c.range =levelCost(baseCosts.range , upgrades.range +1);
  c.hold  =levelCost(baseCosts.hold  , upgrades.hold  +1);
  c.yield =levelCost(baseCosts.yield , upgrades.yield +1);

  ui.costLaserD.textContent=c.laserD; ui.costLaserC.textContent=c.laserC; ui.costMissD.textContent=c.missD;
  ui.costThrust.textContent=c.thrust; ui.costTurn.textContent=c.turn; ui.costMag.textContent=c.magnet;
  ui.costRange.textContent=c.range; ui.costHold.textContent=c.hold; ui.costYield.textContent=c.yield;

  const can=(k)=>ship.credits>=c[k] && upgrades[k]<MAX[k];
  const B=ui.buttons;
  B.buyLaserD.disabled = !can('laserD'); B.buyLaserC.disabled = !can('laserC'); B.buyMissD.disabled  = !can('missD');
  B.buyThrust.disabled = !can('thrust'); B.buyTurn.disabled   = !can('turn');   B.buyMag.disabled    = !can('magnet');
  B.buyRange.disabled  = !can('range');  B.buyHold.disabled   = !can('hold');   B.buyYield.disabled  = !can('yield');

  B.buyLaserD.textContent = (upgrades.laserD>=MAX.laserD)?'MAX':'Buy ('+c.laserD+')';
  B.buyLaserC.textContent = (upgrades.laserC>=MAX.laserC)?'MAX':'Buy ('+c.laserC+')';
  B.buyMissD.textContent  = (upgrades.missD >=MAX.missD )?'MAX':'Buy ('+c.missD+')';
  B.buyThrust.textContent = (upgrades.thrust>=MAX.thrust)?'MAX':'Buy ('+c.thrust+')';
  B.buyTurn.textContent   = (upgrades.turn  >=MAX.turn  )?'MAX':'Buy ('+c.turn+')';
  B.buyMag.textContent    = (upgrades.magnet>=MAX.magnet)?'MAX':'Buy ('+c.magnet+')';
  B.buyRange.textContent  = (upgrades.range >=MAX.range )?'MAX':'Buy ('+c.range+')';
  B.buyHold.textContent   = (upgrades.hold  >=MAX.hold  )?'MAX':'Buy ('+c.hold+')';
  B.buyYield.textContent  = (upgrades.yield >=MAX.yield )?'MAX':'Buy ('+c.yield+')';

  const setUnlock=(key,btn,price)=>{
    if(upgrades[key]){ btn.textContent='Unlocked'; btn.disabled=true; }
    else { btn.textContent=`Unlock (${price})`; btn.disabled=(ship.credits<price); }
  };
  setUnlock('lightning', B.unlockLightning, unlockPrices.lightning);
  setUnlock('mass',      B.unlockMass,      unlockPrices.mass);
  setUnlock('grav',      B.unlockGrav,      unlockPrices.grav);
}

function bindShop(){
  const B=ui.buttons;
  const tryBuy = (k,label)=>{
    if(upgrades[k]>=MAX[k]){ toast(label+' is maxed'); return; }
    const cost=levelCost(baseCosts[k], upgrades[k]+1);
    if(ship.credits<cost){ toast('Not enough credits'); return; }
    ship.credits-=cost; upgrades[k]++; applyUpgrades(); toast(label+' +1');
    save(); updateUI();
  };
  B.buyLaserD.addEventListener('click',()=>tryBuy('laserD','Laser Damage'));
  B.buyLaserC.addEventListener('click',()=>tryBuy('laserC','Laser Cooling'));
  B.buyMissD.addEventListener('click',()=>tryBuy('missD','Missile Damage'));
  B.buyThrust.addEventListener('click',()=>tryBuy('thrust','Engine Thrust'));
  B.buyTurn.addEventListener('click',()=>tryBuy('turn','Turn Rate'));
  B.buyMag.addEventListener('click',()=>tryBuy('magnet','Cargo Magnet'));

  B.buyRange.addEventListener('click',()=>tryBuy('range','Range Extender'));
  B.buyHold.addEventListener('click',()=>tryBuy('hold','Cargo Hold'));
  B.buyYield.addEventListener('click',()=>tryBuy('yield','Refinery Yield'));

  const tryUnlock=(key,price,label,btn)=>{
    if(upgrades[key]) return;
    if(ship.credits<price){ toast('Need '+(price-ship.credits)+' more'); return; }
    ship.credits-=price; upgrades[key]=true; toast('Unlocked '+label+'!');
    btn.textContent='Unlocked'; btn.disabled=true; save(); updateUI();
  };
  B.unlockLightning.addEventListener('click',()=>tryUnlock('lightning',unlockPrices.lightning,'Lightning Beam',B.unlockLightning));
  B.unlockMass.addEventListener('click',()=>tryUnlock('mass',unlockPrices.mass,'Mass Driver',B.unlockMass));
  B.unlockGrav.addEventListener('click',()=>tryUnlock('grav',unlockPrices.grav,'Gravity Gun',B.unlockGrav));
}

/* ---------- Field / Drops ---------- */
let quality='high', seed=(Math.random()*1e9)|0;
const AST={ inst:[], data:[], count:0 };
const DROPS={ inst:null, data:[], count:0, cap:0, geo:null, mat:null };
const MISSILES=[];   // projectiles
const LASER_BEAMS=[];// beam visuals
let stars, planetA, planetB, planetC, planetD;
let skydomeSeed=0;

const RES_KINDS=[{name:'Iron',val:8,color:0xa0a8b8},{name:'Nickel',val:10,color:0x9fb7aa},{name:'Silver',val:14,color:0xc0c0ff},{name:'Gold',val:22,color:0xffd54a},{name:'Platinum',val:30,color:0xd9d9ff},{name:'Iridium',val:40,color:0xa3d1ff}];

/* ---------- Rock / Crystal / Metal geometry ---------- */
function hash3(x,y,z){ return (Math.sin(x*127.1 + y*311.7 + z*74.7)*43758.5453)%1; }
function fbm3(x,y,z,oct=3){ let a=0, amp=1, freq=1; for(let i=0;i<oct;i++){ a+= (hash3(x*freq,y*freq,z*freq)*2-1)*amp; freq*=2.07; amp*=0.55; } return a; }

function geoRock(seed,scale=1){
  const g=new THREE.IcosahedronGeometry(scale,1), pos=g.attributes.position;
  for(let i=0;i<pos.count;i++){
    const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)), n=v.clone().normalize();
    const d=fbm3(v.x+seed*0.001,v.y-seed*0.002,v.z+seed*0.003,4);
    v.addScaledVector(n,(d*0.35) + (Math.random()-0.5)*0.08);
    pos.setXYZ(i,v.x,v.y,v.z);
  }
  g.computeVertexNormals(); return g;
}
function geoCrystal(seed,scale=1){
  const g=new THREE.IcosahedronGeometry(scale,1), pos=g.attributes.position; const R=rng(seed);
  for(let i=0;i<pos.count;i++){
    const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i));
    const n=v.clone().normalize();
    let k = Math.pow(Math.abs(n.x)+Math.abs(n.y)+Math.abs(n.z), 1.25);
    k += (R()-0.5)*0.12;
    v.addScaledVector(n, k*0.55);
    pos.setXYZ(i,v.x,v.y,v.z);
  }
  g.computeVertexNormals(); return g;
}
function geoMetal(seed,scale=1){
  const g=new THREE.IcosahedronGeometry(scale,1), pos=g.attributes.position;
  for(let i=0;i<pos.count;i++){
    const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)), n=v.clone().normalize();
    const d=fbm3(v.x*0.6+seed*0.001,v.y*0.6-seed*0.002,v.z*0.6+seed*0.003,3);
    v.addScaledVector(n,(d*0.18) + (Math.random()-0.5)*0.04);
    pos.setXYZ(i,v.x,v.y,v.z);
  }
  g.computeVertexNormals(); return g;
}

/* ---------- Materials ---------- */
function makeMatRock(){
  const m=new THREE.MeshStandardMaterial({color:0x8a929c, roughness:0.97, metalness:0.03, vertexColors:true, flatShading:true});
  m.onBeforeCompile=(s)=>{ s.fragmentShader = s.fragmentShader.replace('#include <emissivemap_fragment>',
    `#include <emissivemap_fragment>
     float fres = pow(1.0 - saturate(dot(normalize(normal), normalize(vViewPosition))), 3.0);
     #ifdef USE_COLOR
       totalEmissiveRadiance += vec3(0.10) * fres * (0.6 + 0.4*length(vColor));
     #else
       totalEmissiveRadiance += vec3(0.10) * fres;
     #endif` ); };
  return m;
}
function makeMatCrystal(){
  const m=new THREE.MeshStandardMaterial({color:0x8bd7ff, roughness:0.18, metalness:0.0, emissive:new THREE.Color(0x206080), emissiveIntensity:0.25, vertexColors:true, flatShading:true});
  m.onBeforeCompile=(s)=>{ s.fragmentShader = s.fragmentShader.replace('#include <emissivemap_fragment>',
    `#include <emissivemap_fragment>
     float fres = pow(1.0 - saturate(dot(normalize(normal), normalize(vViewPosition))), 2.5);
     totalEmissiveRadiance += vec3(0.20,0.55,0.65) * fres;` ); };
  return m;
}
function makeMatMetal(){
  const m=new THREE.MeshStandardMaterial({color:0xb5b5c0, roughness:0.35, metalness:1.0, vertexColors:true, flatShading:true});
  return m;
}

/* ---------- Build Asteroids (async, with clusters/giants/types) ---------- */
async function buildAsteroidsAsync(seed, progress){
  // Cleanup
  AST.inst.forEach(im=>{ scene.remove(im); im.geometry.dispose(); im.material.dispose(); });
  AST.inst=[]; AST.data=[]; AST.count=0;

  const R=rng(seed^0xBEEF);
  const baseCount=(quality==='ultra')?2000:1300;

  const counts={
    rock: Math.floor(baseCount*0.55),
    crystal: Math.floor(baseCount*0.18),
    metal: Math.floor(baseCount*0.17),
    giants: Math.floor(baseCount*0.02)  // a handful of big boys
  };
  const extraCluster = Math.floor(baseCount*0.08); // sprinkled into rocks

  // Belt shape + clusters
  const beltR=2500,beltW=1200,beltH=800;
  const clusters=[]; const clusterCnt=(quality==='ultra')?14:9;
  for(let c=0;c<clusterCnt;c++){
    const a=R()*Math.PI*2, r=beltR+(R()*2-1)*beltW*0.6;
    clusters.push({pos:new THREE.Vector3(Math.cos(a)*r,(R()*2-1)*beltH*0.5,Math.sin(a)*r), rad:160+R()*240});
  }
  function posBelt(){
    const a=R()*Math.PI*2, r=beltR+(R()*2-1)*beltW, x=Math.cos(a)*r, z=Math.sin(a)*r, y=(R()*2-1)*beltH;
    return new THREE.Vector3(x,y,z);
  }
  function posCluster(){
    const c=clusters[(Math.random()*clusters.length)|0];
    const dir=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
    const d=c.rad*Math.pow(R(),0.7);
    return c.pos.clone().addScaledVector(dir,d);
  }

  // Geometry & materials
  const geosRock=[geoRock(seed^0x1111,1.0), geoRock(seed^0x2222,1.25), geoRock(seed^0x3333,0.85)];
  const geosCrystal=[geoCrystal(seed^0x4444,1.0), geoCrystal(seed^0x5555,0.9)];
  const geosMetal=[geoMetal(seed^0x6666,1.1), geoMetal(seed^0x7777,1.2)];
  const matRock=makeMatRock(), matCrystal=makeMatCrystal(), matMetal=makeMatMetal();

  function allocInst(geo,mat,n){
    const inst=new THREE.InstancedMesh(geo,mat,n);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    inst.instanceColor=new THREE.InstancedBufferAttribute(new Float32Array(n*3),3);
    inst.frustumCulled=false; scene.add(inst);
    const gi=AST.inst.push(inst)-1; return {inst,gi,count:n,idx:0};
  }

  const pools=[];
  function addPools(geos,mat,nTotal){
    const split = geos.map((_g,i)=>Math.floor(nTotal/geos.length)+(i===0?nTotal%geos.length:0));
    for(let i=0;i<geos.length;i++) pools.push(allocInst(geos[i],mat,split[i]));
  }
  addPools(geosRock,   matRock,   counts.rock + extraCluster);
  addPools(geosCrystal,matCrystal,counts.crystal);
  addPools(geosMetal,  matMetal,  counts.metal);

  // Giants (separate pool using rock geo[0])
  const giantsPool = allocInst(geosRock[0], matRock, counts.giants); pools.push(giantsPool);

  function spawnTo(pool, x,y,z, size, hp, color, type){
    if(pool.idx>=pool.count) return;
    const q=new THREE.Quaternion().setFromEuler(new THREE.Euler(R()*Math.PI,R()*Math.PI,R()*Math.PI));
    const m=new THREE.Matrix4().compose(new THREE.Vector3(x,y,z), q, new THREE.Vector3(size,size,size));
    pool.inst.setMatrixAt(pool.idx,m);
    pool.inst.setColorAt(pool.idx,new THREE.Color(color));
    AST.data.push({x,y,z,size,hp,alive:true,gi:pool.gi,idx:pool.idx,type});
    pool.idx++;
    AST.count++;
  }
  function finalizePools(){
    for(const p of pools){
      p.inst.count=p.idx;
      p.inst.instanceMatrix.needsUpdate=true;
      p.inst.instanceColor.needsUpdate=true;
    }
  }

  // Spawning
  let built=0;
  const makeColRock=()=>new THREE.Color().setHSL(0.60+R()*0.06, 0.12+R()*0.10, 0.58+R()*0.10);
  const makeColCrystal=()=>new THREE.Color().setHSL(0.55+R()*0.20, 0.45+R()*0.25, 0.65+R()*0.20);
  const makeColMetal=()=>{ const h=R()<0.5?0.08+R()*0.07:0.58+R()*0.05; return new THREE.Color().setHSL(h,0.22+R()*0.25,0.55+R()*0.15); };

  function choosePool(type){ // round-robin among pools of same material
    const list = pools.filter(p=> {
      const mat=p.inst.material;
      if(type==='rock'   && mat===matRock) return true;
      if(type==='crystal'&& mat===matCrystal) return true;
      if(type==='metal'  && mat===matMetal) return true;
      if(type==='giant'  && p===giantsPool) return true;
      return false;
    });
    // pick the one with room
    for(const p of list){ if(p.idx<p.count) return p; }
    return list[0];
  }

  // rocks + clusters
  for(let i=0;i<counts.rock+extraCluster;i++){
    const pool=choosePool('rock');
    const P=(i<extraCluster)?posCluster():posBelt();
    const size=6+Math.pow(R(),2)*40;
    const hp=Math.round(size*1.2+30);
    spawnTo(pool, P.x,P.y,P.z, size, hp, makeColRock(), 'rock');
    built++; if((i&255)===0){ progress && progress(`Rocks ${Math.floor(built/baseCount*100)}%`); await nextFrame(); }
  }
  // crystals
  for(let i=0;i<counts.crystal;i++){
    const pool=choosePool('crystal');
    const P = (R()<0.35)?posCluster():posBelt();
    const size=5+Math.pow(R(),1.8)*28;
    const hp=Math.round(size*1.0+24);
    spawnTo(pool,P.x,P.y,P.z,size,hp,makeColCrystal(),'crystal');
    if((i&255)===0){ progress && progress('Crystals…'); await nextFrame(); }
  }
  // metal
  for(let i=0;i<counts.metal;i++){
    const pool=choosePool('metal');
    const P=posBelt();
    const size=8+Math.pow(R(),2.2)*36;
    const hp=Math.round(size*1.35+40);
    spawnTo(pool,P.x,P.y,P.z,size,hp,makeColMetal(),'metal');
    if((i&255)===0){ progress && progress('Metal nodes…'); await nextFrame(); }
  }
  // giants
  for(let i=0;i<counts.giants;i++){
    const P=posBelt();
    const size=70+R()*80;
    const hp=Math.round(size*2.0+180);
    spawnTo(giantsPool,P.x,P.y,P.z,size,hp,makeColRock(),'rock');
  }

  finalizePools();
}

/* ---------- Drops ---------- */
function resetDrops(){
  if(DROPS.inst){ scene.remove(DROPS.inst); DROPS.inst.geometry.dispose(); DROPS.inst.material.dispose(); }
  DROPS.count=0; DROPS.data=[]; DROPS.geo=new THREE.OctahedronGeometry(1,0);
  DROPS.mat = new THREE.MeshBasicMaterial({
    vertexColors:true, transparent:true, opacity:0.95,
    blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false
  });
  DROPS.cap=(quality==='ultra'?4000:2400);
  DROPS.inst=new THREE.InstancedMesh(DROPS.geo,DROPS.mat,DROPS.cap);
  DROPS.inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  DROPS.inst.instanceColor=new THREE.InstancedBufferAttribute(new Float32Array(DROPS.cap*3),3);
  scene.add(DROPS.inst);
}
const glowTexLoot=makeGlowTexture(128,0.0,0.55,'rgba(255,240,140,1)');
function spawnDrop(pos,value,color,scale=1.4){
  if(DROPS.count>=DROPS.cap) return;
  const id=DROPS.count++, vel=new THREE.Vector3((Math.random()-0.5)*3,(Math.random()-0.5)*3,(Math.random()-0.5)*3);
  const flare=new THREE.Sprite(new THREE.SpriteMaterial({
    map:glowTexLoot, transparent:true, blending:THREE.AdditiveBlending,
    depthWrite:false, depthTest:true, opacity:0.9, color:new THREE.Color(color)
  }));
  flare.renderOrder = 1;
  flare.position.copy(pos); flare.scale.setScalar(Math.min(32,scale*1.8)); scene.add(flare);
  DROPS.data[id]={pos:pos.clone(),vel,value,alive:true,color,scale,flare};
  const m=new THREE.Matrix4(); m.compose(DROPS.data[id].pos,new THREE.Quaternion(),new THREE.Vector3(scale,scale,scale));
  DROPS.inst.setMatrixAt(id,m); DROPS.inst.setColorAt(id,new THREE.Color(color)); DROPS.inst.count=DROPS.count;
  DROPS.inst.instanceMatrix.needsUpdate=true; DROPS.inst.instanceColor.needsUpdate=true;
}
function addDropsOnDestroy(a){
  const baseScale=clamp(a.size*0.5,1.5,24), count=2+(a.size>30?1:0)+(a.size>70?1:0);
  for(let i=0;i<count;i++){
    const off=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(a.size*0.25);
    const pos=new THREE.Vector3(a.x,a.y,a.z).add(off);
    const col = (a.type==='crystal') ? 0xa3d1ff : (a.type==='metal' ? 0xffd54a : 0xc0c0ff);
    spawnDrop(pos,Math.round(baseScale*12+Math.random()*20),col,baseScale);
  }
}
function maybeChipLoot(p){ if(Math.random()<0.25) spawnDrop(p,Math.round(10+Math.random()*10),0xc0c0ff,1.2); }

function destroyAsteroid(rec){
  if(!rec.alive) return; rec.alive=false;
  const inst=AST.inst[rec.gi], m=new THREE.Matrix4();
  m.compose(new THREE.Vector3(999999,999999,999999),new THREE.Quaternion(),new THREE.Vector3(0.0001,0.0001,0.0001));
  inst.setMatrixAt(rec.idx,m); inst.instanceMatrix.needsUpdate=true;
  addDropsOnDestroy(rec); spawnExplosion(new THREE.Vector3(rec.x,rec.y,rec.z),rec.size);
}

/* ---------- FX & Weapons ---------- */
const FX={ group:new THREE.Group() }; scene.add(FX.group);
function makeBeamGlow(size=96,inner=0,outer=1,col='rgba(130,200,255,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d'); x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer);
  g.addColorStop(0,col); g.addColorStop(1,'rgba(0,0,0,0)');
  x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}
const glowTexBlue = makeBeamGlow(128,0,0.5,'rgba(130,200,255,1)');
const glowTexOrange = makeBeamGlow(128,0,0.5,'rgba(255,180,80,1)');

function spawnExplosion(pos,scale){
  const g=new THREE.SphereGeometry(1,10,8),
  m=new THREE.MeshBasicMaterial({color:0xffaa55,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending,depthWrite:false});
  const s=new THREE.Mesh(g,m); s.position.copy(pos); s.scale.setScalar(0.5); s.userData.t=0; s.userData.life=0.4; s.userData.scale=scale*0.08+0.6; FX.group.add(s);
  const dist=pos.distanceTo(ship.pos); const pct=THREE.MathUtils.clamp(1-dist/1000,0,1);
  if(pct>0){ addShake(0.6*pct, 0.25+0.2*pct); AUD.boom(); screenFlash(0.12*pct); triggerKick(1.2*pct); }
}

function createLaserBeam(start,end){
  const dir=end.clone().sub(start), len=Math.max(0.001,dir.length()), dirN=dir.clone().normalize();
  const gCore=new THREE.CylinderGeometry(1.3,1.3,1,18,1,true);
  const mCore=new THREE.MeshBasicMaterial({color:0x88ccff,transparent:true,opacity:0.95,blending:THREE.AdditiveBlending,depthWrite:false});
  const core=new THREE.Mesh(gCore,mCore);
  const gGlow=new THREE.CylinderGeometry(2.6,2.6,1,18,1,true);
  const mGlow=new THREE.MeshBasicMaterial({color:0x66aaff,transparent:true,opacity:0.35,blending:THREE.AdditiveBlending,depthWrite:false});
  const glow=new THREE.Mesh(gGlow,mGlow);
  const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0),dirN);
  core.quaternion.copy(q); glow.quaternion.copy(q);
  const startSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  const endSprite  =new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  startSprite.scale.set(7,7,1); endSprite.scale.set(9,9,1); scene.add(core,glow,startSprite,endSprite);
  return {start:start.clone(),dir:dirN,len,mesh:core,outer:glow,startGlow:startSprite,endGlow:endSprite,t:0,life:0.22,growTime:0.06};
}
function updateBeam(b,dt){
  b.t+=dt; const p=Math.min(1,b.t/b.growTime), L=b.len*p, mid=b.start.clone().addScaledVector(b.dir,L*0.5);
  b.mesh.position.copy(mid); b.outer.position.copy(mid); b.mesh.scale.set(1,L,1); b.outer.scale.set(1,L,1);
  b.startGlow.position.copy(b.start); b.endGlow.position.copy(b.start.clone().addScaledVector(b.dir,L));
  const f=(b.t<=b.growTime)?1:Math.max(0,1-(b.t-b.growTime)/(b.life-b.growTime));
  b.mesh.material.opacity=0.95*f; b.outer.material.opacity=0.35*f; b.startGlow.material.opacity=0.95*f; b.endGlow.material.opacity=0.95*f;
}
function removeBeam(b){
  scene.remove(b.mesh,b.outer,b.startGlow,b.endGlow);
  b.mesh.geometry.dispose(); b.mesh.material.dispose();
  b.outer.geometry.dispose(); b.outer.material.dispose();
  b.startGlow.material.dispose();
  b.endGlow.material.dispose();
}

function spawnMissile(dir){
  const nose=hardpointWorld(HP_LOCAL.missile);
  const core=new THREE.Mesh(new THREE.SphereGeometry(0.7,14,12), new THREE.MeshBasicMaterial({color:0xffcc88,transparent:true,opacity:1,blending:THREE.AdditiveBlending,depthWrite:false}));
  const glow=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:0.9}));
  glow.scale.set(7,7,1); const group=new THREE.Group(); group.add(glow,core); group.position.copy(nose); scene.add(group);
  MISSILES.push({pos:nose.clone(),vel:dir.clone().multiplyScalar(180),life:10,mesh:group,trailT:0});
}

/* ---------- Aiming / Ray ---------- */
function getReticleRay(){ const origin=camera.position.clone(); const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); return {origin,dir}; }
function rayHitAsteroids(origin,dir,maxRange){
  let bestT=Infinity,best=null;
  for(const a of AST.data){ if(!a.alive) continue;
    const C=new THREE.Vector3(a.x,a.y,a.z), r=a.size, L=C.clone().sub(origin);
    const tca=L.dot(dir); if(tca<0) continue; const d2=L.lengthSq()-tca*tca; if(d2>r*r) continue;
    const thc=Math.sqrt(Math.max(0,r*r-d2)); const t0=tca-thc; if(t0>0&&t0<bestT){ bestT=t0; best=a; }
  }
  if(best && bestT<=maxRange) return {hit:true,t:bestT,rock:best,point:origin.clone().addScaledVector(dir, bestT)};
  return {hit:false,t:maxRange,rock:null,point:origin.clone().addScaledVector(dir,maxRange)};
}

/* ---------- Fire ---------- */
function triggerKick(k){ fovKick=Math.min(4, fovKick + k); }
function screenFlash(a){ flashAmt=Math.min(1, flashAmt+a); }
function fireLaser(){
  const L=ship.laser; if(L.over||L._cd>0) return; L.heat+=L.shotHeat; if(L.heat>=100){ L.over=true; toast('Laser overheated!'); }
  L._cd=1/Math.max(3,ship.laser.rof);
  const {origin,dir}=getReticleRay(); const pick=rayHitAsteroids(origin,dir,ship.range); const endPoint=pick.point.clone();
  const startL=hardpointWorld(HP_LOCAL.laserL), startR=hardpointWorld(HP_LOCAL.laserR);
  LASER_BEAMS.push(createLaserBeam(startL,endPoint)); LASER_BEAMS.push(createLaserBeam(startR,endPoint));
  triggerKick(1.1); screenFlash(0.08); AUD.zap();
  if(pick.hit){ pick.rock.hp-=ship.laser.dmg; maybeChipLoot(endPoint); if(pick.rock.hp<=0) destroyAsteroid(pick.rock); }
}
function fireMissile(){
  const M=ship.missile; if(M.over||M._cd>0) return; M.heat+=M.shotHeat; if(M.heat>=100){ M.over=true; toast('Missiles overheated!'); }
  M._cd=M.reload; const {dir}=getReticleRay(); spawnMissile(dir);
  triggerKick(1.6); screenFlash(0.06);
}

/* ---------- Refinery ---------- */
const REFINERY={ group:null, pos:new THREE.Vector3(0,0,-2600) };
function buildRefinery(){
  if(REFINERY.group){ scene.remove(REFINERY.group); }
  const g=new THREE.Group();
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: makeGlowTexture(256,0.0,0.8,'rgba(120,255,200,1)'), transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.7 }));
  spr.scale.set(110,110,1); g.add(spr);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(36,3,14,64), new THREE.MeshBasicMaterial({color:0x7fffd4,transparent:true,opacity:0.7,blending:THREE.AdditiveBlending,depthWrite:false}));
  g.add(ring); g.position.copy(REFINERY.pos); g.frustumCulled=false; scene.add(g); REFINERY.group=g;
}
let refPrompt=false;
function updateRefinery(){
  const dist=ship.pos.distanceTo(REFINERY.pos);
  ui.ref.textContent=isFinite(dist)?dist.toFixed(0):'—';
  if(dist<90){
    if(!refPrompt){ toast('Press C to Dock (Refinery)'); refPrompt=true; }
    if(keys['KeyC']){
      // Refinery Yield bonus
      const mult = 1 + 0.12*(upgrades.yield-1);
      const bonus=Math.round(ship.cargo*8*mult);
      if(bonus>0){ ship.credits+=bonus; ship.cargo=0; toast(`Refinery +${bonus} cr`); save(); updateUI(); addShake(0.3,0.35); screenFlash(0.1); }
    }
  } else { refPrompt=false; }
}

/* ---------- Save/Load ---------- */
const LSKEY='astrominer_save_v1';
function save(){ localStorage.setItem(LSKEY, JSON.stringify({seed,quality,credits:ship.credits,cargo:ship.cargo,upgrades})); }
function load(){ try{ const j=localStorage.getItem(LSKEY); if(!j) return; const d=JSON.parse(j);
  if(d.seed) seed=d.seed; if(d.quality) quality=d.quality; if(d.credits!=null) ship.credits=d.credits; if(d.cargo!=null) ship.cargo=d.cargo; if(d.upgrades) Object.assign(upgrades,d.upgrades);
  applyUpgrades();
}catch(e){ console.warn('save load failed',e); } }

/* ---------- UI ---------- */
function updateUI(){
  ui.spd.textContent=ship.vel.length().toFixed(1);
  ui.range.textContent=ship.range.toFixed(0);
  ui.credits.textContent=ship.credits|0;
  ui.cargo.textContent=ship.cargo|0;
  ui.cap.textContent=ship.cargoCap|0;
  ui.barLaser.style.width=clamp(ship.laser.heat,0,100)+'%';
  ui.barMiss.style.width =clamp(ship.missile.heat,0,100)+'%';
  ui.barLaser.classList.toggle('warn', ship.laser.heat>85);
  ui.barMiss.classList.toggle('warn', ship.missile.heat>85);
  refreshShop();
}

/* ---------- Target indicator (ring + fill, scales to asteroid) ---------- */
const TARGET={ group:null, rock:null };
function ensureTargetVisual(){
  if(TARGET.group) return;
  const ringGeo=new THREE.RingGeometry(0.92, 1.03, 64);
  const ringMat=new THREE.MeshBasicMaterial({color:0x68ffb0, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending, depthWrite:false});
  const ring=new THREE.Mesh(ringGeo, ringMat);
  const fillGeo=new THREE.CircleGeometry(0.92, 48);
  const fillMat=new THREE.MeshBasicMaterial({color:0x68ffb0, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide});
  const fill=new THREE.Mesh(fillGeo, fillMat);
  const g=new THREE.Group(); g.add(fill,ring); g.visible=false; g.renderOrder=2;
  scene.add(g); TARGET.group=g;
}
function showTarget(rock){
  ensureTargetVisual();
  if(!rock){ TARGET.group.visible=false; ui.tgtHud.style.display='none'; return; }
  TARGET.rock=rock; const pos=new THREE.Vector3(rock.x,rock.y,rock.z);
  TARGET.group.visible=true; TARGET.group.position.copy(pos);
  // face camera
  const look=new THREE.Vector3().subVectors(camera.position,pos).normalize();
  TARGET.group.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), look);
  TARGET.group.scale.setScalar(rock.size*1.03); // slightly larger than asteroid radius
  ui.tgtHud.style.display='block';
  ui.tgtHud.textContent = `${rock.type||'asteroid'} · ${Math.max(0,rock.hp|0)} HP · ${camera.position.distanceTo(pos).toFixed(0)} m`;
}

/* ---------- Loop ---------- */
const clock=new THREE.Clock();
let retTmr=0, retHit=false, currentTarget=null;
function addShake(amp,t){ shakeAmp=Math.max(shakeAmp,amp); shakeT=Math.max(shakeT,t); }
function applyCameraShake(dt){
  if(shakeT>0){ shakeT-=dt; const k=shakeT<=0?0:shakeAmp*(shakeT/(shakeT+0.08));
    camera.position.addScaledVector(new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize(), k*0.15); }
}
function updateScreenFX(dt){
  retTmr-=dt;
  if(retTmr<=0){
    retTmr=0.05;
    const {origin,dir}=getReticleRay();
    const pick=rayHitAsteroids(origin,dir,ship.range);
    retHit=pick.hit; currentTarget = pick.hit ? pick.rock : null; showTarget(currentTarget);
  }
  const root=document.documentElement.style;
  if(retHit){
    root.setProperty('--ret','rgba(120,255,180,.95)');
    root.setProperty('--retGlow','rgba(120,255,180,.65)');
    root.setProperty('--retGlow2','rgba(120,255,180,.45)');
    root.setProperty('--retScale','1.08');
  }else{
    root.setProperty('--ret','rgba(173,216,255,.9)');
    root.setProperty('--retGlow','rgba(120,180,255,.55)');
    root.setProperty('--retGlow2','rgba(120,180,255,.35)');
    root.setProperty('--retScale','1');
  }
  fovKick = lerp(fovKick, 0, Math.min(1, dt*6));
  camera.fov = baseFov + fovKick; camera.updateProjectionMatrix();
  flashAmt = lerp(flashAmt, 0, Math.min(1, dt*6));
  ui.flash.style.opacity = flashAmt.toFixed(3);
}
let fpsAccum=0, fpsFrames=0;
function updateFPS(dt){ if(!fpsOn) return; fpsAccum+=dt; fpsFrames++; if(fpsAccum>=0.25){ const fps=(fpsFrames/fpsAccum); const ms=(1000/fps); ui.fps.textContent=`${fps.toFixed(0)} fps · ${ms.toFixed(1)} ms`; fpsAccum=0; fpsFrames=0; } }

// Stable Auto‑Level
function stableAutoLevel(dt){
  if(!autoLevel || keys['KeyQ'] || keys['KeyE']) return;
  const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat).normalize();
  const worldUp=new THREE.Vector3(0,1,0);
  const desiredRight = new THREE.Vector3().crossVectors(fwd, worldUp);
  const len = desiredRight.length(); if(len<1e-3) return; desiredRight.divideScalar(len);
  const desiredUp = new THREE.Vector3().crossVectors(desiredRight, fwd).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(ship.quat).normalize();
  const rollErr = Math.atan2( right.dot(desiredUp), right.dot(desiredRight) );
  const dead = rad(0.7); if(Math.abs(rollErr) < dead) return;
  const Kp = 3.2, maxRate = rad(60);
  const rate = THREE.MathUtils.clamp(-Kp*rollErr, -maxRate, maxRate);
  const qTrim=new THREE.Quaternion().setFromAxisAngle(fwd, rate*dt);
  ship.quat.premultiply(qTrim).normalize();
}

function handleInput(dt){
  const yaw=((keys['KeyA']?1:0)-(keys['KeyD']?1:0))*ship.yawRate*dt;
  const pitch=((keys['KeyW']?1:0)-(keys['KeyS']?1:0))*ship.pitchRate*dt;
  const roll=((keys['KeyQ']?1:0)-(keys['KeyE']?1:0))*ship.rollRate*dt;
  const qYaw=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),yaw);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),pitch);
  const qRoll=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),-roll);
  ship.quat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();
  stableAutoLevel(dt);

  const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat);
  const up =new THREE.Vector3(0,1,0).applyQuaternion(ship.quat);
  const right=new THREE.Vector3(1,0,0).applyQuaternion(ship.quat);
  const thrustF=(keys['ArrowUp']?1:0)-(keys['ArrowDown']?1:0);
  const thrustX=(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
  const thrustY=(keys['KeyR']?1:0)-(keys['KeyF']?1:0);
  ship.vel.addScaledVector(fwd,thrustF*ship.thrust*dt);
  ship.vel.addScaledVector(right,thrustX*ship.strafe*dt);
  ship.vel.addScaledVector(up,thrustY*ship.lift*dt);
  if(keys['KeyZ']) ship.vel.multiplyScalar(Math.pow(1-0.9,dt*60)); else ship.vel.multiplyScalar(1-ship.dampingLin*dt);
  const spd=ship.vel.length(); if(spd>ship.maxSpeed) ship.vel.multiplyScalar(ship.maxSpeed/spd);
  if(keys['Space']) fireLaser(); if(keys['KeyX'])  fireMissile();
}
function updateMissiles(dt){
  for(let i=MISSILES.length-1;i>=0;i--){
    const m=MISSILES[i];
    const {origin,dir}=getReticleRay(); const pick=rayHitAsteroids(origin,dir,1600);
    if(pick.hit){ const aim=pick.point.clone().sub(m.pos).normalize(); m.vel.lerp(aim.multiplyScalar(200),0.02); }
    m.pos.addScaledVector(m.vel,dt); m.mesh.position.copy(m.pos); m.life-=dt;
    m.trailT=(m.trailT||0)+dt; if(m.trailT>0.03){ m.trailT=0; const s=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:0.8})); s.position.copy(m.pos); s.scale.set(5,5,1); s.userData.t=0; s.userData.life=0.35; FX.group.add(s); }
    let hit=null; for(const a of AST.data){ if(!a.alive) continue; const dx=m.pos.x-a.x,dy=m.pos.y-a.y,dz=m.pos.z-a.z,r=a.size*1.15; if(dx*dx+dy*dy+dz*dz<=r*r){ hit=a; break; } }
    if(hit){ hit.hp-=ship.missile.dmg; if(hit.hp<=0) destroyAsteroid(hit); spawnExplosion(m.pos,2.4); scene.remove(m.mesh); MISSILES.splice(i,1); }
    else if(m.life<=0){ scene.remove(m.mesh); MISSILES.splice(i,1); }
  }
}
function updateDrops(dt){
  const magnetBase = 30 + (upgrades.magnet-1)*12;
  for(let i=0;i<DROPS.count;i++){
    const d=DROPS.data[i]; if(!d||!d.alive) continue;
    d.pos.addScaledVector(d.vel,dt); d.vel.multiplyScalar(0.992);
    if(d.flare){ d.flare.position.copy(d.pos); d.flare.scale.setScalar(Math.min(32,d.scale*1.8)); }
    const toShip=ship.pos.clone().sub(d.pos); const dist=toShip.length();
    const range = magnetBase + d.scale*5.0; if(dist<range){ d.vel.add(toShip.normalize().multiplyScalar(((magnetBase*1.4)+d.scale)*dt)); }
    const pickupR = 6 + d.scale*0.6; if(dist<pickupR){
      d.alive=false; ship.credits+=d.value; ship.cargo=Math.min(ship.cargoCap,ship.cargo+1); toast('+'+d.value+' cr'); AUD.pickup();
      const mtx=new THREE.Matrix4().compose(new THREE.Vector3(999999,999999,999999),new THREE.Quaternion(),new THREE.Vector3(0.0001,0.0001,0.0001));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true; if(d.flare){ scene.remove(d.flare); d.flare.material.dispose(); }
      updateUI(); save();
    } else {
      const mtx=new THREE.Matrix4().compose(d.pos,new THREE.Quaternion(),new THREE.Vector3(d.scale,d.scale,d.scale));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true;
    }
  }
}
function updateFX(dt){
  for(let i=FX.group.children.length-1;i>=0;i--){
    const s=FX.group.children[i]; s.userData.t=(s.userData.t||0)+dt; const t=s.userData.t/(s.userData.life||0.35);
    if(s.isSprite){ s.material.opacity=0.8*(1-t); s.scale.setScalar(THREE.MathUtils.lerp(5,2.2,t)); }
    else { s.scale.setScalar(THREE.MathUtils.lerp(0.5,s.userData.scale||1,t)); s.material.opacity=0.9*(1-t); }
    if(t>=1){ FX.group.remove(s); s.material?.dispose?.(); s.geometry?.dispose?.(); }
  }
  for(let i=LASER_BEAMS.length-1;i>=0;i--){ const b=LASER_BEAMS[i]; updateBeam(b,dt); if(b.t>=b.life){ removeBeam(b); LASER_BEAMS.splice(i,1); } }
}
function loop(){
  const dt=Math.min(0.033,clock.getDelta());
  handleInput(dt); ship.pos.addScaledVector(ship.vel,dt);

  const eye=eyeLocal.clone().applyQuaternion(ship.quat);
  camera.position.copy(ship.pos).add(eye); camera.quaternion.copy(ship.quat);

  applyCameraShake(dt); updateScreenFX(dt); updateFPS(dt);

  shipGroup.position.copy(ship.pos); shipGroup.quaternion.copy(ship.quat);

  ship.laser._cd=Math.max(0,ship.laser._cd-dt); ship.laser.heat=Math.max(0,ship.laser.heat-ship.laser.cooldown*dt); if(ship.laser.over&&ship.laser.heat<=35){ ship.laser.over=false; toast('Laser ready'); }
  ship.missile._cd=Math.max(0,ship.missile._cd-dt); ship.missile.heat=Math.max(0,ship.missile.heat-ship.missile.cooldown*dt); if(ship.missile.over&&ship.missile.heat<=35){ ship.missile.over=false; toast('Missiles ready'); }

  updateMissiles(dt); updateDrops(dt); updateFX(dt); updateRefinery();
  sun.position.copy(ship.pos).add(new THREE.Vector3(1,0.2,0.3).multiplyScalar(30000));
  updateUI(); renderer.render(scene,camera); requestAnimationFrame(loop);
}

/* ---------- Quality / Seed ---------- */
function setQuality(q){ quality=q; ui.qual.textContent=(q==='ultra')?'Ultra':'High'; buildWorldAsync(seed); }
function newSeed(){ seed=(seed*1664525+1013904223)>>>0; buildWorldAsync(seed); }

/* ---------- Build World (async with loader) ---------- */
async function buildWorldAsync(s){
  Loader.show('Generating sector…'); Loader.pct(0.02); Loader.sub('Clearing old objects');

  for(const b of LASER_BEAMS){ removeBeam(b); } LASER_BEAMS.length=0;
  for(let i=MISSILES.length-1;i>=0;i--){ scene.remove(MISSILES[i].mesh); } MISSILES.length=0;
  for(let i=FX.group.children.length-1;i>=0;i--){ const n=FX.group.children[i]; FX.group.remove(n); n.geometry?.dispose?.(); n.material?.dispose?.(); }
  await nextFrame();

  Loader.pct(0.10); Loader.sub('Drops & field'); resetDrops();

  Loader.pct(0.12); Loader.sub('Populating belt…'); await buildAsteroidsAsync(s, (msg)=>Loader.sub(msg)); Loader.pct(0.62);

  // Skydome
  Loader.sub('Skydome'); if(skydome){ scene.remove(skydome); skydome.geometry.dispose(); skydome.material.dispose(); }
  skydomeSeed = s ^ 0xDEADBEEF; skydome = makeSkydome(skydomeSeed); scene.add(skydome); await nextFrame(); Loader.pct(0.70);

  // Stars
  Loader.sub('Seeding stars…'); if(stars) scene.remove(stars);
  const starCount = (quality==='ultra') ? 20000 : 12000;
  stars = await makeStarfieldAsync(s^0x1234, starCount, 90000, (msg)=>Loader.sub(msg));
  scene.add(stars); Loader.pct(0.90);

  // Planets
  Loader.sub('Placing planets…');
  if(planetA) scene.remove(planetA); if(planetB) scene.remove(planetB); if(planetC) scene.remove(planetC); if(planetD) scene.remove(planetD);
  function makePlanet(radius,dist,colorHex,withRing=false){
    const group=new THREE.Group();
    const g=new THREE.SphereGeometry(radius,32,16);
    const m=new THREE.MeshStandardMaterial({color:colorHex,roughness:0.95,metalness:0.0});
    const sphere=new THREE.Mesh(g,m); group.add(sphere);
    const halo=new THREE.Sprite(new THREE.SpriteMaterial({ map: makeGlowTexture(192,0.0,0.65,'rgba(120,180,255,1)'), transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.22 }));
    halo.scale.set(radius*2.8, radius*2.8, 1); group.add(halo);
    if(withRing){
      const rg=new THREE.RingGeometry(radius*1.35, radius*2.0, 64);
      const rm=new THREE.MeshBasicMaterial({color:0xbad4ff,transparent:true,opacity:0.16,side:THREE.DoubleSide,depthWrite:false});
      const ring=new THREE.Mesh(rg,rm); ring.rotation.x=Math.PI*0.44; ring.rotation.z=Math.PI*0.18; group.add(ring);
    }
    group.position.set(dist*0.8,dist*0.2,-dist); group.frustumCulled=false; return group;
  }
  planetA=makePlanet(4200,70000,0x1f2a7a,false); scene.add(planetA);
  planetB=makePlanet(2600,110000,0x7a3f1f,true); scene.add(planetB);
  planetC=makePlanet(5200,180000,0x263a96,true); scene.add(planetC);
  planetD=makePlanet(3500,220000,0x8c3b1d,false); scene.add(planetD);
  await nextFrame(); Loader.pct(1.0);

  buildRefinery();

  ship.pos.set(0,0,0); ship.vel.set(0,0,0); ship.quat.identity();
  ship.laser.heat=0; ship.laser.over=false; ship.laser._cd=0; ship.missile.heat=0; ship.missile.over=false; ship.missile._cd=0;
  ui.seed.textContent=s; ui.cap.textContent=ship.cargoCap; updateUI(); Loader.hide();
}

/* ---------- Boot ---------- */
function onResize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize',onResize);

async function init(){
  bindShop(); load(); applyUpgrades();
  ui.qual.textContent=(quality==='ultra')?'Ultra':'High'; ui.seed.textContent=seed; refreshShop();
  scene.background=new THREE.Color(0x000000); await buildWorldAsync(seed); requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>

