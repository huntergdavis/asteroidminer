<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AstroMiner — FP Reticle • Omni Glow • Skydome • FPS Toggle</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --ret: rgba(173,216,255,.9);
    --retGlow: rgba(120,180,255,.55);
    --retGlow2: rgba(120,180,255,.35);
    --retScale: 1;
  }
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#eef}
  #app{position:fixed;inset:0;overflow:hidden}

  .hud{position:absolute;left:10px;top:10px;background:rgba(0,0,0,.45);padding:10px 12px;border-radius:12px;font-size:12px;backdrop-filter:blur(2px);line-height:1.25}
  .shop{position:absolute;right:10px;top:10px;background:rgba(0,0,0,.55);padding:10px 12px;border-radius:12px;min-width:260px;max-width:340px;font-size:12px}
  .shop h3{margin:0 0 6px;font-size:13px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0}
  .row button{background:#1f3b8f;border:0;color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}
  .row button[disabled]{opacity:.45;cursor:not-allowed}
  .k{opacity:.8}
  .bar{height:8px;background:#223;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(#66e,#44a);width:0}
  .bar.red>span{background:linear-gradient(#f66,#b22)}
  .bar>span.warn{animation:blink .35s linear infinite alternate}
  @keyframes blink{from{filter:brightness(1)}to{filter:brightness(2.1)}}
  .cash{font-weight:700}
  .help{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:12px;max-width:640px}
  .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:10px;font-size:12px;display:none}
  .err{position:absolute;right:10px;bottom:10px;background:#300;color:#fee;padding:8px 10px;border-radius:10px;max-width:60ch;display:none;white-space:pre-wrap}

  .ret{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(var(--retScale));pointer-events:none;opacity:.9}
  .ret .ring{width:46px;height:46px;border:2px solid var(--ret);border-radius:50%;box-shadow:0 0 18px var(--retGlow) inset,0 0 22px var(--retGlow2)}
  .ret .lines{position:absolute;left:0;top:0;width:46px;height:46px}
  .ret .lines::before,.ret .lines::after{content:"";position:absolute;background:var(--ret)}
  .ret .lines::before{left:50%;top:-10px;transform:translateX(-50%);width:2px;height:12px;box-shadow:0 44px 0 0 var(--ret)}
  .ret .lines::after{top:50%;left:-10px;transform:translateY(-50%);height:2px;width:12px;box-shadow:44px 0 0 0 var(--ret)}

  .flash{position:fixed;inset:0;pointer-events:none;opacity:0;mix-blend-mode:screen;background:
    radial-gradient(ellipse at center, rgba(255,255,255,.14), rgba(0,0,0,0) 60%);}

  .fps{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,.55);padding:8px 10px;border-radius:10px;font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:none}
</style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Seed:</b> <span id="uiSeed">0</span> · <b>Quality:</b> <span id="uiQual">High</span></div>
  <div style="margin-top:6px"><b>Speed:</b> <span id="uiSpd">0</span> m/s · <b>Range:</b> <span id="uiRange">0</span> m</div>
  <div style="margin-top:6px"><b>Laser Heat</b><div class="bar"><span id="barLaser"></span></div></div>
  <div style="margin-top:6px"><b>Missile Heat</b><div class="bar red"><span id="barMiss"></span></div></div>
  <div style="margin-top:6px"><b>Cargo</b>: <span id="uiCargo">0</span> / <span id="uiCap">100</span></div>
  <div><b>Credits</b>: <span class="cash" id="uiCredits">0</span></div>
  <div style="margin-top:6px"><b>Refinery</b>: <span id="uiRef">—</span> m (Dock: <b>C</b>)</div>
</div>

<div class="shop" id="shop">
  <h3>Ship Upgrades</h3>
  <div class="row"><span>Laser Damage Lv <b id="lvLaserD">1</b></span><button id="buyLaserD">Buy (<span id="costLaserD">200</span>)</button></div>
  <div class="row"><span>Laser Cooling Lv <b id="lvLaserC">1</b></span><button id="buyLaserC">Buy (<span id="costLaserC">150</span>)</button></div>
  <div class="row"><span>Missile Damage Lv <b id="lvMissD">1</b></span><button id="buyMissD">Buy (<span id="costMissD">300</span>)</button></div>
  <div class="row"><span>Engine Thrust Lv <b id="lvThrust">1</b></span><button id="buyThrust">Buy (<span id="costThrust">250</span>)</button></div>
  <div class="row"><span>Turn Rate Lv <b id="lvTurn">1</b></span><button id="buyTurn">Buy (<span id="costTurn">200</span>)</button></div>
  <div class="row"><span>Cargo Magnet Lv <b id="lvMag">1</b></span><button id="buyMag">Buy (<span id="costMag">180</span>)</button></div>
  <hr style="border-color:#234">
  <div class="row"><span class="k">Lightning Beam</span><button id="unlockLightning">Locked (1200)</button></div>
  <div class="row"><span class="k">Mass Driver</span><button id="unlockMass">Locked (900)</button></div>
  <div class="row"><span class="k">Gravity Gun</span><button id="unlockGrav">Locked (1500)</button></div>
  <div style="margin-top:6px;opacity:.75">
    Toggle shop: <b>U</b> · Quality: <b>1</b>=High, <b>2</b>=Ultra · New Seed: <b>N</b> · Auto‑Level: <b>L</b> · FPS: <b>Shift+F</b>
  </div>
</div>

<div class="help">
  <div><b>Controls</b> — Zero-G 6-DOF</div>
  <div>Pitch: <b>W/S</b> (direct up/down) · Yaw: <b>A/D</b> · Roll: <b>Q/E</b></div>
  <div>Forward/Reverse: <b>↑/↓</b> · Strafe: <b>←/→</b> · Lift: <b>R/F</b></div>
  <div>Brake/Damp: <b>Z</b> · Laser: <b>Space</b> · Missile: <b>X</b> · Dock: <b>C</b> · Auto‑Level: <b>L</b> · FPS: <b>Shift+F</b></div>
</div>

<!-- Reticle -->
<div class="ret"><div class="ring"></div><div class="lines"></div></div>

<div class="flash" id="flash"></div>
<div class="fps" id="fps">—</div>
<div class="toast" id="toast"></div>
<div class="err" id="err"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- Utils ---------- */
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const rad=THREE.MathUtils.degToRad;
function rng(seed){ let s=seed>>>0; return ()=>{ s+=0x6D2B79F5; let t=Math.imul(s^(s>>>15),1|s); t^=t+Math.imul(t^(t>>>7),61|t); return ((t^(t>>>14))>>>0)/4294967296; }; }

/* ---------- Scene ---------- */
const app=document.getElementById('app');
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,240000);
camera.position.set(0,0,0);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:false});
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setSize(innerWidth,innerHeight);
app.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x222233,0.95));
const sun=new THREE.DirectionalLight(0xffffff,0.8); sun.position.set(1,0.2,0.3).multiplyScalar(30000); scene.add(sun);

/* ---------- Glow texture helper (used by halos, drops, beams) ---------- */
function finalizeGlowTexture(t){
  t.anisotropy = 2;                  // modest; keep it cheap
  t.generateMipmaps = false;         // avoid edge bleed in mips
  t.minFilter = THREE.LinearFilter;
  t.magFilter = THREE.LinearFilter;
  t.wrapS = THREE.ClampToEdgeWrapping;
  t.wrapT = THREE.ClampToEdgeWrapping;
  t.premultiplyAlpha = true;
  t.colorSpace = THREE.SRGBColorSpace;
  t.needsUpdate = true;
  return t;
}
function makeGlowTexture(size=96, inner=0.0, outer=1.0, col='rgba(255,240,140,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d');
  x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer);
  g.addColorStop(0,col);
  g.addColorStop(1,'rgba(0,0,0,0)');
  x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}

/* ---------- Stars (kept light) ---------- */
function makeStarfield(seed, count, spread=90000){
  const group=new THREE.Group();
  const R=rng(seed);
  function layer(n, spr, size){
    const geo=new THREE.BufferGeometry();
    const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const r=spr*Math.pow(R(),0.22);
      const th=R()*Math.PI*2;
      const u=R()*2-1;
      const ph=Math.acos(u);
      const s=Math.sin(ph);
      pos[i*3]=r*s*Math.cos(th);
      pos[i*3+1]=r*Math.cos(ph);
      pos[i*3+2]=r*s*Math.sin(th);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat=new THREE.PointsMaterial({
      size, color:0xffffff, sizeAttenuation:true,
      transparent:true, opacity:0.9, depthWrite:false
    });
    const pts=new THREE.Points(geo,mat);
    pts.frustumCulled=false;
    group.add(pts);
  }
  layer(Math.floor(count*0.6), spread*0.9, 2.0);
  layer(Math.floor(count*0.7), spread*1.8, 1.3);
  layer(Math.floor(count*0.7), spread*2.6, 1.0);
  group.frustumCulled=false;
  return group;
}

/* ---------- Procedural Skydome (replaces billboards; zero overdraw) ---------- */
let skydome=null;
function makeSkydome(seed){
  const R=rng(seed);
  const c0=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c1=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const c2=new THREE.Vector3(R()*2-1,R()*2-1,R()*2-1).normalize();
  const mat=new THREE.ShaderMaterial({
    side:THREE.BackSide, depthTest:false, depthWrite:false, transparent:false,
    uniforms:{
      uC0:{value:c0}, uC1:{value:c1}, uC2:{value:c2},
      uCol0:{value:new THREE.Color(0.40,0.30,0.70)}, // violet
      uCol1:{value:new THREE.Color(0.70,0.40,0.20)}, // warm
      uCol2:{value:new THREE.Color(0.20,0.50,0.80)}, // blue
      uBase:{value:new THREE.Color(0.004,0.006,0.010)}
    },
    vertexShader:`
      varying vec3 vDir;
      void main(){
        vec4 wp = modelMatrix * vec4(position,1.0);
        vDir = normalize(wp.xyz - cameraPosition);
        gl_Position = projectionMatrix * viewMatrix * wp;
      }
    `,
    fragmentShader:`
      precision mediump float;
      varying vec3 vDir;
      uniform vec3 uC0, uC1, uC2;
      uniform vec3 uCol0, uCol1, uCol2, uBase;
      float lobe(vec3 d, vec3 c, float sharp){
        float m = max(0.0, dot(normalize(d), normalize(c)));
        return pow(m, sharp);
      }
      void main(){
        vec3 d = normalize(vDir);
        float a = lobe(d,uC0,2.0);
        float b = lobe(d,uC1,2.0);
        float c = lobe(d,uC2,2.0);
        vec3 col = uBase + 0.5*(a*uCol0 + b*uCol1 + c*uCol2);
        gl_FragColor = vec4(col,1.0);
      }
    `
  });
  const g=new THREE.SphereGeometry(220000, 32, 16);
  const dome=new THREE.Mesh(g,mat);
  dome.renderOrder = -100; // render first
  dome.frustumCulled=false;
  return dome;
}

/* ---------- DOM/UI ---------- */
const byId = id=>document.getElementById(id);
const ui={
  seed:byId('uiSeed'), qual:byId('uiQual'),
  spd:byId('uiSpd'), range:byId('uiRange'),
  barLaser:byId('barLaser'), barMiss:byId('barMiss'),
  credits:byId('uiCredits'), cargo:byId('uiCargo'), cap:byId('uiCap'),
  toast:byId('toast'), err:byId('err'), shop:byId('shop'),
  lvLaserD:byId('lvLaserD'), lvLaserC:byId('lvLaserC'), lvMissD:byId('lvMissD'),
  lvThrust:byId('lvThrust'), lvTurn:byId('lvTurn'), lvMag:byId('lvMag'),
  costLaserD:byId('costLaserD'), costLaserC:byId('costLaserC'), costMissD:byId('costMissD'),
  costThrust:byId('costThrust'), costTurn:byId('costTurn'), costMag:byId('costMag'),
  ref:byId('uiRef'),
  flash:byId('flash'),
  fps:byId('fps')
};
function toast(msg,ms=1200){ ui.toast.textContent=msg; ui.toast.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>ui.toast.style.display='none',ms); }
function showError(e){ ui.err.style.display='block'; ui.err.textContent=(typeof e==='string')?e:(e?.message||String(e)); console.error(e); }
addEventListener('error', e=>showError(e.error||e.message));
addEventListener('unhandledrejection', e=>showError(e.reason||e));

/* ---------- Input ---------- */
const keys={};
let fpsOn=false;
function toggleFPS(){ fpsOn=!fpsOn; ui.fps.style.display=fpsOn?'block':'none'; }
addEventListener('keydown',e=>{
  // FPS overlay — Shift+F (F is lift)
  if(e.code==='KeyF' && e.shiftKey){ toggleFPS(); e.preventDefault(); return; }

  keys[e.code]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  if(e.code==='Digit1') setQuality('high');
  if(e.code==='Digit2') setQuality('ultra');
  if(e.code==='KeyN')  newSeed();
  if(e.code==='KeyU')  toggleShop();
  if(e.code==='KeyL')  autoLevel=!autoLevel, toast('Auto-Level: '+(autoLevel?'ON':'OFF'));

  // prime/resume audio on first gesture
  if(AUD._ctx && AUD._ctx.state==='suspended') AUD._ctx.resume();
  if(!AUD._ctx) AUD.init();
});
addEventListener('keyup',e=>{ keys[e.code]=false; });
function toggleShop(){ ui.shop.style.display = (ui.shop.style.display==='none'?'block':'none'); }
ui.shop.style.display='block';

/* ---------- Audio (no assets) ---------- */
const AUD={
  _ctx:null,
  init(){ try{ const C=window.AudioContext||window.webkitAudioContext; this._ctx=new C(); }catch(e){} },
  beep(freq=880,dur=0.05,type='sine',gain=0.03){
    if(!this._ctx) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type=type; o.frequency.setValueAtTime(freq,t);
    g.gain.setValueAtTime(gain,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+dur);
  },
  zap(){ this.beep(880,0.05,'sawtooth',0.05); this.beep(1760,0.05,'triangle',0.03); },
  pickup(){ this.beep(1200,0.06,'sine',0.045); setTimeout(()=>this.beep(1600,0.05,'sine',0.035),40); },
  boom(){
    if(!this._ctx) return; const t=this._ctx.currentTime;
    const o=this._ctx.createOscillator(); const g=this._ctx.createGain();
    o.type='square'; o.frequency.setValueAtTime(80,t); o.frequency.exponentialRampToValueAtTime(30,t+0.3);
    g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.35);
    o.connect(g).connect(this._ctx.destination); o.start(t); o.stop(t+0.35);
  }
};

/* ---------- Ship ---------- */
const ship={
  pos:new THREE.Vector3(), vel:new THREE.Vector3(), quat:new THREE.Quaternion(),
  thrust:48, strafe:36, lift:36,
  yawRate:rad(100), pitchRate:rad(100), rollRate:rad(180),
  dampingLin:0.08, maxSpeed:300, range:3800,
  cargo:0, cargoCap:100, credits:0,
  laser:{ canFire:true, heat:0, over:false, cooldown:30, shotHeat:18, dmg:50, rof:10, _cd:0 },
  missile:{ canFire:true, heat:0, over:false, cooldown:18, shotHeat:34, dmg:240, reload:0.7, _cd:0 }
};
let autoLevel=false;
let baseFov=75, fovKick=0, flashAmt=0, shakeT=0, shakeAmp=0;

const shipGroup=new THREE.Group(); scene.add(shipGroup); shipGroup.visible=false; // true FPV
const HP_LOCAL = { laserL:new THREE.Vector3(-0.9,0.55,-1.6), laserR:new THREE.Vector3(0.9,0.55,-1.6), missile:new THREE.Vector3(0,-0.05,-1.9) };
const eyeLocal = new THREE.Vector3(0,0.18,0);
function hardpointWorld(local){ return local.clone().applyQuaternion(ship.quat).add(ship.pos); }

/* ---------- Upgrades ---------- */
const upgrades={ laserD:1, laserC:1, missD:1, thrust:1, turn:1, magnet:1, lightning:false, mass:false, grav:false };
const baseCosts={ laserD:200, laserC:150, missD:300, thrust:250, turn:200, magnet:180 };
function levelCost(base,lv){ return Math.round(base * Math.pow(1.6, lv-1)); }
function refreshShop(){
  ui.lvLaserD.textContent=upgrades.laserD; ui.lvLaserC.textContent=upgrades.laserC; ui.lvMissD.textContent=upgrades.missD;
  ui.lvThrust.textContent=upgrades.thrust; ui.lvTurn.textContent=upgrades.turn; ui.lvMag.textContent=upgrades.magnet;
  ui.costLaserD.textContent=levelCost(baseCosts.laserD, upgrades.laserD+1);
  ui.costLaserC.textContent=levelCost(baseCosts.laserC, upgrades.laserC+1);
  ui.costMissD.textContent=levelCost(baseCosts.missD, upgrades.missD+1);
  ui.costThrust.textContent=levelCost(baseCosts.thrust, upgrades.thrust+1);
  ui.costTurn.textContent=levelCost(baseCosts.turn, upgrades.turn+1);
  ui.costMag.textContent=levelCost(baseCosts.magnet, upgrades.magnet+1);
}

/* ---------- Field / Drops ---------- */
let quality='high', seed=(Math.random()*1e9)|0;
const AST={ inst:[], data:[], count:0, geo:[], mat:null };
const DROPS={ inst:null, data:[], count:0, cap:0, geo:null, mat:null };
const MISSILES=[];   // projectiles
const LASER_BEAMS=[];// beam visuals
let stars, planetA, planetB, planetC, planetD;
let skydomeSeed=0;

const RES_KINDS=[{name:'Iron',val:8,color:0xa0a8b8},{name:'Nickel',val:10,color:0x9fb7aa},{name:'Silver',val:14,color:0xc0c0ff},{name:'Gold',val:22,color:0xffd54a},{name:'Platinum',val:30,color:0xd9d9ff},{name:'Iridium',val:40,color:0xa3d1ff}];
const lootColorForSize = sz => (sz>18?0xffd54a:sz>12?0xd9d9ff:sz>8?0xc0c0ff:0xa0a8b8);

function makeRockGeometry(seed,scale=1){ const g=new THREE.IcosahedronGeometry(scale,1),pos=g.attributes.position,R=rng(seed);
  for(let i=0;i<pos.count;i++){ const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)), n=v.clone().normalize(); v.addScaledVector(n,(R()-0.5)*(0.35+R()*0.55)); pos.setXYZ(i,v.x,v.y,v.z); }
  g.computeVertexNormals(); return g;
}
function resetAsteroids(){ AST.inst.forEach(im=>{ scene.remove(im); im.geometry.dispose(); im.material.dispose(); }); AST.inst=[]; AST.data=[]; AST.count=0; AST.geo=[]; }
function buildAsteroids(seed){
  resetAsteroids();
  const count=(quality==='ultra')?1800:900;
  AST.geo=[ makeRockGeometry(seed^0x1111,1), makeRockGeometry(seed^0x2222,1.2), makeRockGeometry(seed^0x3333,0.9) ];
  AST.mat=new THREE.MeshStandardMaterial({color:0x88909a, roughness:0.95, metalness:0.05});
  const per=[Math.floor(count*0.4),Math.floor(count*0.35),count-Math.floor(count*0.4)-Math.floor(count*0.35)];
  const beltR=2500,beltW=1200,beltH=800,R=rng(seed^0xBEEF);
  for(let gi=0;gi<3;gi++){
    const n=per[gi], inst=new THREE.InstancedMesh(AST.geo[gi],AST.mat,n);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage); inst.frustumCulled=false; scene.add(inst); AST.inst.push(inst);
    for(let i=0;i<n;i++){
      const a=R()*Math.PI*2, r=beltR+(R()*2-1)*beltW, x=Math.cos(a)*r, z=Math.sin(a)*r, y=(R()*2-1)*beltH;
      const size=6+Math.pow(R(),2)*40, hp=Math.round((size*1.1)+(gi*6));
      const rot=new THREE.Quaternion().setFromEuler(new THREE.Euler(R()*Math.PI,R()*Math.PI,R()*Math.PI));
      const m=new THREE.Matrix4(); m.compose(new THREE.Vector3(x,y,z),rot,new THREE.Vector3(size,size,size));
      inst.setMatrixAt(i,m); AST.data.push({x,y,z,size,hp,alive:true,gi,idx:i}); AST.count++;
    }
    inst.instanceMatrix.needsUpdate=true;
  }
}

function resetDrops(){
  if(DROPS.inst){ scene.remove(DROPS.inst); DROPS.inst.geometry.dispose(); DROPS.inst.material.dispose(); }
  DROPS.count=0; DROPS.data=[]; DROPS.geo=new THREE.OctahedronGeometry(1,0);
  DROPS.mat = new THREE.MeshBasicMaterial({
    vertexColors:true,
    transparent:true,
    opacity:0.95,
    blending:THREE.AdditiveBlending,
    side:THREE.DoubleSide,
    depthWrite:false
  });
  DROPS.cap=(quality==='ultra'?3500:2000);
  DROPS.inst=new THREE.InstancedMesh(DROPS.geo,DROPS.mat,DROPS.cap);
  DROPS.inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  DROPS.inst.instanceColor=new THREE.InstancedBufferAttribute(new Float32Array(DROPS.cap*3),3);
  scene.add(DROPS.inst);
}
const glowTexLoot=makeGlowTexture(128,0.0,0.55,'rgba(255,240,140,1)');
function spawnDrop(pos,value,color,scale=1.4){
  if(DROPS.count>=DROPS.cap) return;
  const id=DROPS.count++, vel=new THREE.Vector3((Math.random()-0.5)*3,(Math.random()-0.5)*3,(Math.random()-0.5)*3);
  const flare=new THREE.Sprite(new THREE.SpriteMaterial({
    map:glowTexLoot, transparent:true, blending:THREE.AdditiveBlending,
    depthWrite:false, depthTest:false, opacity:0.9, color:new THREE.Color(color)
  }));
  flare.renderOrder = 5;
  flare.position.copy(pos); flare.scale.setScalar(Math.min(32,scale*1.8)); scene.add(flare);
  DROPS.data[id]={pos:pos.clone(),vel,value,alive:true,color,scale,flare};
  const m=new THREE.Matrix4(); m.compose(DROPS.data[id].pos,new THREE.Quaternion(),new THREE.Vector3(scale,scale,scale));
  DROPS.inst.setMatrixAt(id,m); DROPS.inst.setColorAt(id,new THREE.Color(color)); DROPS.inst.count=DROPS.count;
  DROPS.inst.instanceMatrix.needsUpdate=true; DROPS.inst.instanceColor.needsUpdate=true;
}
function addDropsOnDestroy(a){
  const baseScale=clamp(a.size*0.5,1.5,20), count=2+(a.size>20?1:0);
  for(let i=0;i<count;i++){
    const off=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).multiplyScalar(a.size*0.25);
    const pos=new THREE.Vector3(a.x,a.y,a.z).add(off);
    const kind = RES_KINDS[Math.min(RES_KINDS.length-1, Math.floor((baseScale/20)*RES_KINDS.length))];
    spawnDrop(pos,Math.round(baseScale*12+Math.random()*20),kind.color,baseScale);
  }
}
function maybeChipLoot(p){ if(Math.random()<0.25) spawnDrop(p,Math.round(10+Math.random()*10),0xc0c0ff,1.2); }

function destroyAsteroid(rec){
  if(!rec.alive) return; rec.alive=false;
  const inst=AST.inst[rec.gi], m=new THREE.Matrix4();
  m.compose(new THREE.Vector3(999999,999999,999999),new THREE.Quaternion(),new THREE.Vector3(0.0001,0.0001,0.0001));
  inst.setMatrixAt(rec.idx,m); inst.instanceMatrix.needsUpdate=true;
  addDropsOnDestroy(rec); spawnExplosion(new THREE.Vector3(rec.x,rec.y,rec.z),rec.size);
}

/* ---------- FX & Weapons ---------- */
const FX={ group:new THREE.Group() }; scene.add(FX.group);
function makeBeamGlow(size=96,inner=0,outer=1,col='rgba(130,200,255,1)'){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const x=c.getContext('2d');
  x.clearRect(0,0,size,size);
  const g=x.createRadialGradient(size/2,size/2,size*inner,size/2,size/2,size*outer);
  g.addColorStop(0,col); g.addColorStop(1,'rgba(0,0,0,0)');
  x.fillStyle=g; x.fillRect(0,0,size,size);
  return finalizeGlowTexture(new THREE.CanvasTexture(c));
}
const glowTexBlue = makeBeamGlow(128,0,0.5,'rgba(130,200,255,1)');
const glowTexOrange = makeBeamGlow(128,0,0.5,'rgba(255,180,80,1)');

function spawnExplosion(pos,scale){
  const g=new THREE.SphereGeometry(1,10,8),
  m=new THREE.MeshBasicMaterial({color:0xffaa55,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending,depthWrite:false});
  const s=new THREE.Mesh(g,m); s.position.copy(pos); s.scale.setScalar(0.5); s.userData.t=0; s.userData.life=0.4; s.userData.scale=scale*0.08+0.6; FX.group.add(s);
  // camera shake + boom if near
  const dist=pos.distanceTo(ship.pos);
  const pct=THREE.MathUtils.clamp(1-dist/1000,0,1);
  if(pct>0){ addShake(0.6*pct, 0.25+0.2*pct); AUD.boom(); screenFlash(0.12*pct); triggerKick(1.2*pct); }
}

function createLaserBeam(start,end){
  const dir=end.clone().sub(start), len=Math.max(0.001,dir.length()), dirN=dir.clone().normalize();
  const gCore=new THREE.CylinderGeometry(1.3,1.3,1,18,1,true);
  const mCore=new THREE.MeshBasicMaterial({color:0x88ccff,transparent:true,opacity:0.95,blending:THREE.AdditiveBlending,depthWrite:false});
  const core=new THREE.Mesh(gCore,mCore);
  const gGlow=new THREE.CylinderGeometry(2.6,2.6,1,18,1,true);
  const mGlow=new THREE.MeshBasicMaterial({color:0x66aaff,transparent:true,opacity:0.35,blending:THREE.AdditiveBlending,depthWrite:false});
  const glow=new THREE.Mesh(gGlow,mGlow);
  const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0),dirN);
  core.quaternion.copy(q); glow.quaternion.copy(q);
  const startSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  const endSprite  =new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexBlue,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,opacity:0.95}));
  startSprite.scale.set(7,7,1); endSprite.scale.set(9,9,1); scene.add(core,glow,startSprite,endSprite);
  return {start:start.clone(),dir:dirN,len,mesh:core,outer:glow,startGlow:startSprite,endGlow:endSprite,t:0,life:0.22,growTime:0.06};
}
function updateBeam(b,dt){
  b.t+=dt; const p=Math.min(1,b.t/b.growTime), L=b.len*p, mid=b.start.clone().addScaledVector(b.dir,L*0.5);
  b.mesh.position.copy(mid); b.outer.position.copy(mid); b.mesh.scale.set(1,L,1); b.outer.scale.set(1,L,1);
  b.startGlow.position.copy(b.start); b.endGlow.position.copy(b.start.clone().addScaledVector(b.dir,L));
  const f=(b.t<=b.growTime)?1:Math.max(0,1-(b.t-b.growTime)/(b.life-b.growTime));
  b.mesh.material.opacity=0.95*f; b.outer.material.opacity=0.35*f; b.startGlow.material.opacity=0.95*f; b.endGlow.material.opacity=0.95*f;
}
function removeBeam(b){
  scene.remove(b.mesh,b.outer,b.startGlow,b.endGlow);
  b.mesh.geometry.dispose(); b.mesh.material.dispose();
  b.outer.geometry.dispose(); b.outer.material.dispose();
  b.startGlow.material.dispose();
  b.endGlow.material.dispose();
}

function spawnMissile(dir){
  const nose=hardpointWorld(HP_LOCAL.missile);
  const core=new THREE.Mesh(new THREE.SphereGeometry(0.7,14,12), new THREE.MeshBasicMaterial({color:0xffcc88,transparent:true,opacity:1,blending:THREE.AdditiveBlending,depthWrite:false}));
  const glow=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:0.9}));
  glow.scale.set(7,7,1); const group=new THREE.Group(); group.add(glow,core); group.position.copy(nose); scene.add(group);
  MISSILES.push({pos:nose.clone(),vel:dir.clone().multiplyScalar(180),life:10,mesh:group,trailT:0});
}

/* ---------- Aiming / Ray ---------- */
function getReticleRay(){ const origin=camera.position.clone();
  const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize(); return {origin,dir}; }
function rayHitAsteroids(origin,dir,maxRange){
  let bestT=Infinity,best=null;
  for(const a of AST.data){ if(!a.alive) continue;
    const C=new THREE.Vector3(a.x,a.y,a.z), r=a.size, L=C.clone().sub(origin);
    const tca=L.dot(dir); if(tca<0) continue; const d2=L.lengthSq()-tca*tca; if(d2>r*r) continue;
    const thc=Math.sqrt(Math.max(0,r*r-d2)); const t0=tca-thc; if(t0>0&&t0<bestT){ bestT=t0; best=a; }
  }
  if(best && bestT<=maxRange) return {hit:true,t:bestT,rock:best,point:origin.clone().addScaledVector(dir,bestT)};
  return {hit:false,t:maxRange,rock:null,point:origin.clone().addScaledVector(dir,maxRange)};
}

/* ---------- Fire ---------- */
function triggerKick(k){ fovKick=Math.min(4, fovKick + k); }
function screenFlash(a){ flashAmt=Math.min(1, flashAmt+a); }
function fireLaser(){
  const L=ship.laser; if(L.over||L._cd>0) return; L.heat+=L.shotHeat; if(L.heat>=100){ L.over=true; toast('Laser overheated!'); }
  L._cd=1/Math.max(3,ship.laser.rof);
  const {origin,dir}=getReticleRay(); const pick=rayHitAsteroids(origin,dir,ship.range); const endPoint=pick.point.clone();
  const startL=hardpointWorld(HP_LOCAL.laserL), startR=hardpointWorld(HP_LOCAL.laserR);
  LASER_BEAMS.push(createLaserBeam(startL,endPoint)); LASER_BEAMS.push(createLaserBeam(startR,endPoint));
  triggerKick(1.1); screenFlash(0.08); AUD.zap();
  if(pick.hit){ pick.rock.hp-=ship.laser.dmg; maybeChipLoot(endPoint); if(pick.rock.hp<=0) destroyAsteroid(pick.rock); }
}
function fireMissile(){
  const M=ship.missile; if(M.over||M._cd>0) return; M.heat+=M.shotHeat; if(M.heat>=100){ M.over=true; toast('Missiles overheated!'); }
  M._cd=M.reload; const {dir}=getReticleRay(); spawnMissile(dir);
  triggerKick(1.6); screenFlash(0.06);
}

/* ---------- Refinery ---------- */
const REFINERY={ group:null, pos:new THREE.Vector3(0,0,-2600) };
function buildRefinery(){
  if(REFINERY.group){ scene.remove(REFINERY.group); }
  const g=new THREE.Group();
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({
    map: makeGlowTexture(256,0.0,0.8,'rgba(120,255,200,1)'),
    transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.7
  }));
  spr.scale.set(110,110,1); g.add(spr);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(36,3,14,64),
    new THREE.MeshBasicMaterial({color:0x7fffd4,transparent:true,opacity:0.7,blending:THREE.AdditiveBlending,depthWrite:false}));
  g.add(ring);
  g.position.copy(REFINERY.pos);
  g.frustumCulled=false;
  scene.add(g);
  REFINERY.group=g;
}
let refPrompt=false;
function updateRefinery(dt){
  const dist=ship.pos.distanceTo(REFINERY.pos);
  ui.ref.textContent=isFinite(dist)?dist.toFixed(0):'—';
  if(dist<90){
    if(!refPrompt){ toast('Press C to Dock (Refinery)'); refPrompt=true; }
    if(keys['KeyC']){
      const bonus=Math.round(ship.cargo*8);
      if(bonus>0){ ship.credits+=bonus; ship.cargo=0; toast(`Refinery +${bonus} cr (cargo delivered)`); save(); updateUI(); addShake(0.3,0.35); screenFlash(0.1); }
    }
  } else { refPrompt=false; }
}

/* ---------- Save/Load ---------- */
const LSKEY='astrominer_save_v1';
function save(){ localStorage.setItem(LSKEY, JSON.stringify({seed,quality,credits:ship.credits,cargo:ship.cargo,upgrades})); }
function load(){ try{ const j=localStorage.getItem(LSKEY); if(!j) return; const d=JSON.parse(j);
  if(d.seed) seed=d.seed; if(d.quality) quality=d.quality; if(d.credits!=null) ship.credits=d.credits; if(d.cargo!=null) ship.cargo=d.cargo; if(d.upgrades) Object.assign(upgrades,d.upgrades);
  ship.laser.dmg=50+(upgrades.laserD-1)*18; ship.laser.cooldown=30+(upgrades.laserC-1)*6; ship.laser.shotHeat=Math.max(8,18-(upgrades.laserC-1)*2);
  ship.missile.dmg=240+(upgrades.missD-1)*80;
  ship.thrust = 48 + (upgrades.thrust-1)*7;
  ship.strafe = 36 + (upgrades.thrust-1)*6;
  ship.lift   = 36 + (upgrades.thrust-1)*6;
  ship.maxSpeed = 300 + (upgrades.thrust-1)*24;
  ship.yawRate=rad(100+(upgrades.turn-1)*10); ship.pitchRate=rad(100+(upgrades.turn-1)*10); ship.rollRate=rad(180+(upgrades.turn-1)*18);
  ship.cargoCap=100+(upgrades.magnet-1)*50; }catch(e){ console.warn('save load failed',e); } }

/* ---------- UI ---------- */
function updateUI(){
  ui.spd.textContent=ship.vel.length().toFixed(1);
  ui.range.textContent=ship.range.toFixed(0);
  ui.credits.textContent=ship.credits|0;
  ui.cargo.textContent=ship.cargo|0;
  ui.barLaser.style.width=clamp(ship.laser.heat,0,100)+'%';
  ui.barMiss.style.width =clamp(ship.missile.heat,0,100)+'%';
  ui.barLaser.classList.toggle('warn', ship.laser.heat>85);
  ui.barMiss.classList.toggle('warn', ship.missile.heat>85);
  refreshShop();
}

/* ---------- Loop ---------- */
const clock=new THREE.Clock();
let retTmr=0, retHit=false;
function addShake(amp,t){ shakeAmp=Math.max(shakeAmp,amp); shakeT=Math.max(shakeT,t); }
function applyCameraShake(dt){
  if(shakeT>0){
    shakeT-=dt; const k=shakeT<=0?0:shakeAmp*(shakeT/(shakeT+0.08));
    camera.position.addScaledVector(new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize(), k*0.15);
  }
}
function updateScreenFX(dt){
  // reticle hit probe (throttled)
  retTmr-=dt; if(retTmr<=0){ retTmr=0.05; const {origin,dir}=getReticleRay(); const pick=rayHitAsteroids(origin,dir,ship.range); retHit=pick.hit; }
  const root=document.documentElement.style;
  if(retHit){
    root.setProperty('--ret','rgba(120,255,180,.95)');
    root.setProperty('--retGlow','rgba(120,255,180,.65)');
    root.setProperty('--retGlow2','rgba(120,255,180,.45)');
    root.setProperty('--retScale','1.08');
  }else{
    root.setProperty('--ret','rgba(173,216,255,.9)');
    root.setProperty('--retGlow','rgba(120,180,255,.55)');
    root.setProperty('--retGlow2','rgba(120,180,255,.35)');
    root.setProperty('--retScale','1');
  }

  // fov kick + screen flash ease
  fovKick = THREE.MathUtils.lerp(fovKick, 0, Math.min(1, dt*6));
  camera.fov = baseFov + fovKick; camera.updateProjectionMatrix();

  flashAmt = THREE.MathUtils.lerp(flashAmt, 0, Math.min(1, dt*6));
  ui.flash.style.opacity = flashAmt.toFixed(3);
}

// lightweight FPS meter
let fpsAccum=0, fpsFrames=0;
function updateFPS(dt){
  if(!fpsOn) return;
  fpsAccum+=dt; fpsFrames++;
  if(fpsAccum>=0.25){
    const fps=(fpsFrames/fpsAccum);
    const ms=(1000/fps);
    ui.fps.textContent=`${fps.toFixed(0)} fps · ${ms.toFixed(1)} ms`;
    fpsAccum=0; fpsFrames=0;
  }
}

function handleInput(dt){
  const yaw=((keys['KeyA']?1:0)-(keys['KeyD']?1:0))*ship.yawRate*dt;
  const pitch=((keys['KeyW']?1:0)-(keys['KeyS']?1:0))*ship.pitchRate*dt; // W=up, S=down
  const roll=((keys['KeyQ']?1:0)-(keys['KeyE']?1:0))*ship.rollRate*dt;
  const qYaw=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),yaw);
  const qPitch=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),pitch);
  const qRoll=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),-roll);
  ship.quat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  // Optional mild auto-level (trim roll back toward world up) when no roll keys held
  if(autoLevel && !keys['KeyQ'] && !keys['KeyE']){
    const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat);
    const up=new THREE.Vector3(0,1,0).applyQuaternion(ship.quat);
    const worldUp=new THREE.Vector3(0,1,0);
    const right=new THREE.Vector3().crossVectors(fwd,up).normalize();
    const rollAngle=Math.atan2(right.dot(worldUp), up.dot(worldUp));
    const trim=-rollAngle*0.9*dt;
    const qTrim=new THREE.Quaternion().setFromAxisAngle(fwd,trim);
    ship.quat.premultiply(qTrim).normalize();
  }

  const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(ship.quat);
  const up =new THREE.Vector3(0,1,0).applyQuaternion(ship.quat);
  const right=new THREE.Vector3(1,0,0).applyQuaternion(ship.quat);

  const thrustF=(keys['ArrowUp']?1:0)-(keys['ArrowDown']?1:0);
  const thrustX=(keys['ArrowRight']?1:0)-(keys['ArrowLeft']?1:0);
  const thrustY=(keys['KeyR']?1:0)-(keys['KeyF']?1:0);
  ship.vel.addScaledVector(fwd,thrustF*ship.thrust*dt);
  ship.vel.addScaledVector(right,thrustX*ship.strafe*dt);
  ship.vel.addScaledVector(up,thrustY*ship.lift*dt);

  if(keys['KeyZ']) ship.vel.multiplyScalar(Math.pow(1-0.9,dt*60)); else ship.vel.multiplyScalar(1-ship.dampingLin*dt);

  const spd=ship.vel.length(); if(spd>ship.maxSpeed) ship.vel.multiplyScalar(ship.maxSpeed/spd);

  if(keys['Space']) fireLaser();
  if(keys['KeyX'])  fireMissile();
}
function updateMissiles(dt){
  for(let i=MISSILES.length-1;i>=0;i--){
    const m=MISSILES[i];
    const {origin,dir}=getReticleRay(); const pick=rayHitAsteroids(origin,dir,1600);
    if(pick.hit){ const aim=pick.point.clone().sub(m.pos).normalize(); m.vel.lerp(aim.multiplyScalar(200),0.02); }
    m.pos.addScaledVector(m.vel,dt); m.mesh.position.copy(m.pos); m.life-=dt;
    m.trailT=(m.trailT||0)+dt; if(m.trailT>0.03){ m.trailT=0; const s=new THREE.Sprite(new THREE.SpriteMaterial({map:glowTexOrange,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,opacity:0.8})); s.position.copy(m.pos); s.scale.set(5,5,1); s.userData.t=0; s.userData.life=0.35; FX.group.add(s); }
    let hit=null; for(const a of AST.data){ if(!a.alive) continue; const dx=m.pos.x-a.x,dy=m.pos.y-a.y,dz=m.pos.z-a.z,r=a.size*1.15; if(dx*dx+dy*dy+dz*dz<=r*r){ hit=a; break; } }
    if(hit){ hit.hp-=ship.missile.dmg; if(hit.hp<=0) destroyAsteroid(hit); spawnExplosion(m.pos,2.4); scene.remove(m.mesh); MISSILES.splice(i,1); }
    else if(m.life<=0){ scene.remove(m.mesh); MISSILES.splice(i,1); }
  }
}
function updateDrops(dt){
  const magnetBase = 30 + (upgrades.magnet-1)*12;
  for(let i=0;i<DROPS.count;i++){
    const d=DROPS.data[i]; if(!d||!d.alive) continue;
    d.pos.addScaledVector(d.vel,dt); d.vel.multiplyScalar(0.992);
    if(d.flare){ d.flare.position.copy(d.pos); d.flare.scale.setScalar(Math.min(32,d.scale*1.8)); }
    const toShip=ship.pos.clone().sub(d.pos); const dist=toShip.length();
    const range = magnetBase + d.scale*5.0; if(dist<range){ d.vel.add(toShip.normalize().multiplyScalar(((magnetBase*1.4)+d.scale)*dt)); }
    const pickupR = 6 + d.scale*0.6; if(dist<pickupR){
      d.alive=false; ship.credits+=d.value; ship.cargo=Math.min(ship.cargoCap,ship.cargo+1); toast('+'+d.value+' cr');
      AUD.pickup();
      const mtx=new THREE.Matrix4(); mtx.compose(new THREE.Vector3(999999,999999,999999),new THREE.Quaternion(),new THREE.Vector3(0.0001,0.0001,0.0001));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true; if(d.flare){ scene.remove(d.flare); d.flare.material.dispose(); }
      updateUI(); save();
    } else {
      const mtx=new THREE.Matrix4(); mtx.compose(d.pos,new THREE.Quaternion(),new THREE.Vector3(d.scale,d.scale,d.scale));
      DROPS.inst.setMatrixAt(i,mtx); DROPS.inst.instanceMatrix.needsUpdate=true;
    }
  }
}
function updateFX(dt){
  for(let i=FX.group.children.length-1;i>=0;i--){
    const s=FX.group.children[i]; s.userData.t=(s.userData.t||0)+dt; const t=s.userData.t/(s.userData.life||0.35);
    if(s.isSprite){ s.material.opacity=0.8*(1-t); s.scale.setScalar(THREE.MathUtils.lerp(5,2.2,t)); }
    else { s.scale.setScalar(THREE.MathUtils.lerp(0.5,s.userData.scale||1,t)); s.material.opacity=0.9*(1-t); }
    if(t>=1){ FX.group.remove(s); s.material?.dispose?.(); s.geometry?.dispose?.(); }
  }
  for(let i=LASER_BEAMS.length-1;i>=0;i--){ const b=LASER_BEAMS[i]; updateBeam(b,dt); if(b.t>=b.life){ removeBeam(b); LASER_BEAMS.splice(i,1); } }
}
function loop(){
  const dt=Math.min(0.033,clock.getDelta());
  handleInput(dt); ship.pos.addScaledVector(ship.vel,dt);

  // first-person: camera locked to ship nose
  const eye=eyeLocal.clone().applyQuaternion(ship.quat);
  camera.position.copy(ship.pos).add(eye); camera.quaternion.copy(ship.quat);

  // shake + screen FX after camera is placed
  applyCameraShake(dt);
  updateScreenFX(dt);
  updateFPS(dt);

  // keep hidden ship group synced for hardpoints
  shipGroup.position.copy(ship.pos); shipGroup.quaternion.copy(ship.quat);

  // cooldowns
  ship.laser._cd=Math.max(0,ship.laser._cd-dt); ship.laser.heat=Math.max(0,ship.laser.heat-ship.laser.cooldown*dt); if(ship.laser.over&&ship.laser.heat<=35){ ship.laser.over=false; toast('Laser ready'); }
  ship.missile._cd=Math.max(0,ship.missile._cd-dt); ship.missile.heat=Math.max(0,ship.missile.heat-ship.missile.cooldown*dt); if(ship.missile.over&&ship.missile.heat<=35){ ship.missile.over=false; toast('Missiles ready'); }

  updateMissiles(dt); updateDrops(dt); updateFX(dt); updateRefinery(dt);
  sun.position.copy(ship.pos).add(new THREE.Vector3(1,0.2,0.3).multiplyScalar(30000));
  updateUI(); renderer.render(scene,camera); requestAnimationFrame(loop);
}

/* ---------- Quality / Seed ---------- */
function setQuality(q){ quality=q; ui.qual.textContent=(q==='ultra')?'Ultra':'High'; buildWorld(seed); }
function newSeed(){ seed=(seed*1664525+1013904223)>>>0; buildWorld(seed); }

/* ---------- Build World ---------- */
function buildWorld(s){
  for(const b of LASER_BEAMS){ removeBeam(b); } LASER_BEAMS.length=0;
  for(let i=MISSILES.length-1;i>=0;i--){ scene.remove(MISSILES[i].mesh); } MISSILES.length=0;
  for(let i=FX.group.children.length-1;i>=0;i--){ const n=FX.group.children[i]; FX.group.remove(n); n.geometry?.dispose?.(); n.material?.dispose?.(); }
  resetDrops(); buildAsteroids(s);

  // Skydome (procedural gradient, no blending)
  if(skydome){ scene.remove(skydome); skydome.geometry.dispose(); skydome.material.dispose(); }
  skydomeSeed = s ^ 0xDEADBEEF;
  skydome = makeSkydome(skydomeSeed);
  scene.add(skydome);

  // Stars
  if(stars) scene.remove(stars);
  const starCount = (quality==='ultra') ? 20000 : 12000; // slightly reduced for perf
  stars = makeStarfield(s^0x1234, starCount, 90000);
  scene.add(stars);

  // Planets (reduced halo cost a bit)
  if(planetA) scene.remove(planetA);
  if(planetB) scene.remove(planetB);
  if(planetC) scene.remove(planetC);
  if(planetD) scene.remove(planetD);

  function makePlanet(radius,dist,colorHex,withRing=false){
    const group=new THREE.Group();
    const g=new THREE.SphereGeometry(radius,32,16);
    const m=new THREE.MeshStandardMaterial({color:colorHex,roughness:0.95,metalness:0.0});
    const sphere=new THREE.Mesh(g,m); group.add(sphere);
    // smaller/cheaper halo
    const halo=new THREE.Sprite(new THREE.SpriteMaterial({
      map: makeGlowTexture(192,0.0,0.65,'rgba(120,180,255,1)'),
      transparent:true, blending:THREE.AdditiveBlending,
      depthWrite:false, opacity:0.22
    }));
    halo.scale.set(radius*2.8, radius*2.8, 1); group.add(halo);
    if(withRing){
      const rg=new THREE.RingGeometry(radius*1.35, radius*2.0, 64);
      const rm=new THREE.MeshBasicMaterial({color:0xbad4ff,transparent:true,opacity:0.16,side:THREE.DoubleSide,depthWrite:false});
      const ring=new THREE.Mesh(rg,rm); ring.rotation.x=Math.PI*0.44; ring.rotation.z=Math.PI*0.18; group.add(ring);
    }
    group.position.set(dist*0.8,dist*0.2,-dist); group.frustumCulled=false; return group;
  }

  planetA = makePlanet(4200,  70000,  0x1f2a7a, false); scene.add(planetA);
  planetB = makePlanet(2600, 110000,  0x7a3f1f, true ); scene.add(planetB);
  planetC = makePlanet(5200, 180000,  0x263a96, true ); scene.add(planetC);
  planetD = makePlanet(3500, 220000,  0x8c3b1d, false); scene.add(planetD);

  buildRefinery();

  ship.pos.set(0,0,0); ship.vel.set(0,0,0); ship.quat.identity();
  ship.laser.heat=0; ship.laser.over=false; ship.laser._cd=0; ship.missile.heat=0; ship.missile.over=false; ship.missile._cd=0;
  ui.seed.textContent=s; ui.cap.textContent=ship.cargoCap; updateUI();
}

/* ---------- Boot ---------- */
function onResize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize',onResize);
function init(){
  load(); ui.qual.textContent=(quality==='ultra')?'Ultra':'High'; ui.seed.textContent=seed; refreshShop();
  scene.background=new THREE.Color(0x000000);
  buildWorld(seed);
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>

